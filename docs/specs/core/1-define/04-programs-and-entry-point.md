## Programs and Entry Point

This document specifies how Raster “programs” are defined for the Core toolchain, how an entry point is designated/selected, and how external inputs are represented and validated by the current implementation.

### Code audit tasks (where to look)

- **Core types that define “program-shaped” data**
  - `crates/raster-core/src/manifest.rs`: `Manifest` (project-level list of tiles + sequences; currently no entry-point field).
  - `crates/raster-core/src/schema.rs`: `SequenceSchema` + `ControlFlow` (intended std-only schema; not currently generated by the compiler).
  - `crates/raster-core/src/cfs.rs`: `ControlFlowSchema` + `SequenceDef` + `InputSource` (the schema currently generated by `cargo raster cfs`).
  - `crates/raster-core/src/error.rs`: `Error::{InvalidTileId, InvalidSequence, Serialization, Other}`.

- **How tiles and sequences become “part of a program” (registration vs source discovery)**
  - `crates/raster-macros/src/lib.rs`
    - `#[tile]`: generates a byte-oriented ABI entry (`__raster_tile_entry_*`) using `postcard::{from_bytes,to_allocvec}`.
    - `#[sequence]`: registers a sequence ID and a static list of callees extracted from the function body (simple call extraction).
  - `crates/raster-core/src/registry.rs`: `TILE_REGISTRY`, `SEQUENCE_REGISTRY`, and lookup helpers such as `find_tile_by_str`, `find_sequence`.

- **How “main” / entry is selected today**
  - `crates/raster-cli/src/main.rs`: `cargo raster preview` defaults `--sequence` to `"main"`.
  - `crates/raster-cli/src/commands.rs`: `preview()` selects a discovered sequence by ID; no additional “entry” metadata is used.

- **How external inputs are defined and (not) validated today**
  - `crates/raster-macros/src/lib.rs`: tile ABI decoding rules (unit / single arg / tuple) and serialization error messages.
  - `crates/raster-cli/src/commands.rs`: `run()` / `preview()` convert `--input` JSON into `serde_json::Value`, then `postcard`-encode that value (this is a key behavioral constraint / mismatch; see “Current gaps”).
  - `crates/raster-compiler/src/ast.rs`: `CallVisitor` extracts callsites and argument expressions (stringified tokens) from parsed Rust syntax trees.
  - `crates/raster-compiler/src/sequence.rs`: `SequenceDiscovery` selects `#[sequence]` functions and uses extracted call infos.
  - `crates/raster-compiler/src/flow_resolver.rs`: `FlowResolver` binds arguments to `InputSource` values (sequence params, prior outputs, or external fallback).

- **Program packaging / artifacts**
  - `crates/raster-compiler/src/builder.rs`: artifact layout under `target/raster/tiles/<tile_id>/<backend>/` (`guest.elf`, `method_id`, `manifest.json`).
  - `crates/raster-cli/src/commands.rs`: `cfs()` writes `target/raster/cfs.json`.
  - `crates/raster-runtime/src/tracing.rs` and `crates/raster-runtime/src/tracing/subscriber/*`: tracing/commitment subscribers used by `#[raster::main]`.

### Specification

#### What constitutes a “program” to Core

- A Raster program MUST be understood as the combination of:
  - A set of **tile definitions** (callable computation units).
  - A set of **sequence definitions** (named compositions that invoke tiles and/or other sequences).

- A program MAY be represented in two (currently coexisting) ways:
  - **In-process representation (linked program)**: tiles and sequences are present in a Rust binary that links them, and they are discoverable through the global registries (`TILE_REGISTRY`, `SEQUENCE_REGISTRY`) on supported targets.
  - **Out-of-process representation (described program)**: tiles and sequences are described by a serialized schema (currently `ControlFlowSchema` / “CFS”), and tile artifacts are stored on disk for backend execution.

- A program MUST treat **IDs** as the primary identity keys:
  - A tile’s ID is its Rust function identifier (currently used as both `id` and `name` in macro-generated metadata).
  - A sequence’s ID is its Rust function identifier.

#### Entry point (entry sequence) selection

- Raster distinguishes:
  - The **host entry point**: Rust’s `fn main()` in the host binary (not part of Core’s program model).
  - The **program entry point**: a **sequence ID** selected for execution by a runner/tool.

- A runner MUST identify an entry sequence by a string ID and MUST fail if that ID does not resolve to exactly one defined sequence.

- By convention, tools SHOULD treat the sequence ID `"main"` as the default entry sequence when an entry sequence is not explicitly provided.

- A program SHOULD define a sequence whose ID is `"main"` if it intends to be runnable without additional CLI configuration.

- Sequence IDs MUST be unique within the program.
  - If duplicates exist, the program is invalid and a runner MUST reject it.

#### External inputs (what they are)

- External inputs are values provided by the execution environment (CLI, host application, test harness) to satisfy:
  - The **parameters of the entry sequence**, and/or
  - Any **unbound** arguments within a sequence’s call graph (see “Current gaps” for how this is handled today).

- At the Core ABI boundary for tiles, external inputs MUST be represented as an opaque byte string that is decoded using the Postcard encoding (`postcard::from_bytes`).

#### External inputs to tiles (tile ABI rules)

Given a tile function \(f\) annotated with `#[tile(...)]`:

- The tile ABI MUST decode its input bytes as follows:
  - If \(f\) has **0 arguments**, the input bytes MUST decode as unit `()`.
  - If \(f\) has **1 argument** of type `T`, the input bytes MUST decode as `T`.
  - If \(f\) has **N>1 arguments** with types `(T0, T1, ..., Tn)`, the input bytes MUST decode as the tuple `(T0, T1, ..., Tn)`.

- After executing the tile’s Rust function, the tile ABI MUST encode the returned value using Postcard (`postcard::to_allocvec`).

- If Postcard decoding fails, execution MUST error with a serialization error.
  - The current implementation formats this as `Error::Serialization("Failed to deserialize input: ...")`.

#### External inputs to sequences (sequence ABI rules)

- A sequence is a Rust function annotated with `#[sequence]` that is intended to be used as a composition unit.
- Core currently does not define a byte-level ABI for sequences (there is no generated “sequence entry” wrapper that performs serialization/deserialization).
- Runners/tools that execute sequences MUST define how sequence parameters are sourced from external inputs.

#### Program packaging (what’s produced today)

Tools in this repository currently package a program as:

- **Per-tile artifacts** (per backend), stored at:
  - `target/raster/tiles/<tile_id>/<backend>/guest.elf` (if produced by the backend)
  - `target/raster/tiles/<tile_id>/<backend>/method_id` (hex-encoded method/image ID)
  - `target/raster/tiles/<tile_id>/<backend>/manifest.json` (tile artifact manifest)

- **A control flow schema file** (CFS) stored at:
  - `target/raster/cfs.json`

The packaged program MAY be reconstructed by combining:
- The CFS (which lists tiles and sequences), and
- The tile artifacts for the selected backend.

##### Tile artifact manifest (`manifest.json`)

- Each tile artifact directory MUST contain a JSON file named `manifest.json`.
- The manifest MUST be encoded as UTF-8 JSON and MUST contain the following keys:
  - `tile_id` (string): the tile ID.
  - `backend` (string): backend name (e.g., `"risc0"`, `"native"`).
  - `method_id` (string): lowercase hex encoding of the backend’s method/image ID bytes.
  - `elf_size` (number): size of `guest.elf` in bytes (0 if no ELF was written).
  - `source_hash` (string, optional): a build-cache hash of the tile’s source file. If absent, build tooling MUST treat the cache as invalid.

Example:

```json
{
  "tile_id": "greet",
  "backend": "risc0",
  "method_id": "0123abcd",
  "elf_size": 123456,
  "source_hash": "0f0e0d0c0b0a090800000001e240"
}
```

##### Control flow schema file (`cfs.json`)

- The CFS file MUST be valid JSON encoding of `raster_core::cfs::ControlFlowSchema`.
- The CFS MUST contain:
  - `version` (string): currently emitted as `"1.0"`.
  - `project` (string): project name (best-effort extracted from `Cargo.toml`).
  - `encoding` (string): currently emitted as `"postcard"`.
  - `tiles` (array): each element describes a tile’s `id`, `type`, `inputs`, `outputs`.
  - `sequences` (array): each element describes a sequence’s `id`, its `input_sources`, and its ordered `items` with `input_sources`.

Minimal illustrative example:

```json
{
  "version": "1.0",
  "project": "hello-tiles",
  "encoding": "postcard",
  "tiles": [
    { "id": "greet", "type": "iter", "inputs": 1, "outputs": 1 }
  ],
  "sequences": [
    {
      "id": "main",
      "input_sources": [{ "source": { "type": "external" } }],
      "items": [
        {
          "item_type": "tile",
          "item_id": "greet",
          "input_sources": [{ "source": { "type": "seq_input", "input_index": 0 } }]
        }
      ]
    }
  ]
}
```

#### Errors and rejection conditions

A runner/tool MUST reject a program (or invocation) when:

- The selected entry sequence ID is missing.
- The selected entry sequence ID is ambiguous (duplicate IDs).
- A tile ID referenced by an executable plan cannot be resolved to an artifact/registration.
- Any required external input cannot be decoded into the expected Postcard type at the tile ABI boundary.

### Current gaps / mismatches in the implementation

These are behaviors that the surrounding toolchain currently does not fully implement or enforce:

- **No sequence ABI + no entry-sequence execution engine**
  - Core’s std-only `SequenceSchema` generation (`raster-compiler/src/schema_gen.rs`) is TODO.
  - There is no schema-driven runtime that executes a `SequenceSchema` as a program.
  - Practical execution today happens via “run a single tile” (`cargo raster run-tile`) or “run the user program binary” (`cargo raster run --backend native`) rather than a full sequence interpreter.

- **CLI input encoding mismatch**
  - `cargo raster run` / `preview` currently parse `--input` as JSON and Postcard-encode a `serde_json::Value`.
  - Tile ABIs decode using the tile’s Rust argument type(s), not `serde_json::Value`.
  - As a result, CLI-provided input bytes will only decode successfully if the tile’s input type is compatible with Postcard decoding of `serde_json::Value` (typically: the tile takes `serde_json::Value`), which is not the common authoring style.

- **“main” is a convention only**
  - Tools default to `--sequence main`, but nothing enforces that a `#[sequence] fn main(...)` exists.
  - Example projects may define an entry sequence with a different ID, requiring explicit `--sequence`.

- **Uniqueness and type/arity checks are not enforced**
  - Source discovery does not currently reject duplicate sequence IDs or duplicate tile IDs.
  - The CFS does not carry per-parameter or per-output types, so tools cannot validate type compatibility; it only carries arity counts and coarse dataflow bindings.

### Examples

#### Example: defining an entry sequence by convention

```rust
use raster::prelude::*;

#[tile]
fn greet(name: String) -> String {
    format!("Hello, {name}")
}

#[sequence]
fn main(name: String) -> String {
    greet(name)
}
```

In this model, the program entry point is the sequence ID `"main"` (the function name), not Rust’s `fn main()` host entry.

#### Example: tile external input encoding (single arg vs tuple)

```rust
use raster::core::postcard;

// For fn add(a: u64, b: u64) -> u64
let input_bytes = postcard::to_allocvec(&(2u64, 40u64)).unwrap();

// For fn greet(name: String) -> String
let input_bytes = postcard::to_allocvec(&"Raster".to_string()).unwrap();

// For fn tick() -> u64
let input_bytes = postcard::to_allocvec(&()).unwrap();
```

