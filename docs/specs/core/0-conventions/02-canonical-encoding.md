## Canonical Encoding

This document specifies the **canonical byte encodings** used by Raster **as implemented today**, and how those encodings are identified and recorded in schemas and artifacts. It is written for implementers and auditors.

Raster currently has two distinct “serialization layers”:

- **Tile I/O encoding**: the byte encoding used for tile ABI inputs and outputs (and therefore for any “external inputs” that feed those tiles at runtime).
- **Metadata/schema encoding**: the encoding used to persist control-flow metadata (CFS, manifests, etc.).

Where the current codebase does not fully enforce the desired properties (e.g. determinism, explicit encoding identifiers), this spec calls that out as a **GAP**.

---

### Code audit tasks (where to look)

- **Tile ABI encoding (input/output bytes)**
  - **Macro-generated ABI wrapper**: `crates/raster-macros/src/lib.rs` (`#[tile]` emits `__raster_tile_entry_<name>`)
    - `postcard::from_bytes(input)` for decoding tile parameters
    - `postcard::to_allocvec(&result)` for encoding tile return value
  - **Registry ABI surface**: `crates/raster-core/src/registry.rs` (`TileEntryFn = fn(&[u8]) -> Result<Vec<u8>>`)
  - **Core re-exports**: `crates/raster-core/src/lib.rs` (`pub use postcard;`)
- **External input handling**
  - **CFS “external” bindings**: `crates/raster-core/src/cfs.rs` (`InputSource::External`)
  - **CFS builder uses encoding label**: `crates/raster-compiler/src/cfs_builder.rs` (`encoding: "postcard"`)
  - **CLI input path**: `crates/raster-cli/src/commands.rs` (`run`, `preview`) for JSON input parsing and byte serialization
- **Encoding identifier handling**
  - **CFS field**: `crates/raster-core/src/cfs.rs` (`ControlFlowSchema.encoding: String`)
  - **Serialization of CFS itself**: `crates/raster-cli/src/commands.rs` (`serde_json::to_string_pretty(&cfs)`)
- **zkVM framing / integration**
  - **Host env write format**: `crates/raster-backend-risc0/src/risc0.rs` (`ExecutorEnv::builder().write(&u32).write_slice(bytes)`)
  - **Guest read format**: `crates/raster-backend-risc0/src/guest_builder.rs` (generated guest reads `u32` then `read_slice`)
- **Artifact/manifests**
  - **Tile artifact manifest**: `crates/raster-compiler/src/builder.rs` (writes `tiles/<tile_id>/<backend>/manifest.json`)
  - **RISC0 guest builder manifest**: `crates/raster-backend-risc0/src/guest_builder.rs` (writes `manifest.json`)
  - **Project manifest types (std only)**: `crates/raster-core/src/manifest.rs`

---

### 1. Canonical tile I/O encoding (implemented)

#### 1.1 Tile ABI byte contract

Each tile has an ABI entrypoint (generated by `#[tile]`) with signature:

- `fn __raster_tile_entry_<tile_id>(input: &[u8]) -> Result<Vec<u8>>`

The ABI contract is:

- **Input encoding**:
  - The `input` byte slice MUST be a `postcard` encoding of the tile’s parameters.
  - If the tile has:
    - **0 parameters**: `input` MUST be a `postcard` encoding of `()`.
    - **1 parameter of type `T`**: `input` MUST be a `postcard` encoding of a `T`.
    - **N>1 parameters `T1..TN`**: `input` MUST be a `postcard` encoding of the tuple `(T1, .., TN)`.
- **Output encoding**:
  - The returned `Vec<u8>` MUST be a `postcard` encoding of the tile’s return value `R`.
  - If the tile returns `Result<R, E>`, the wrapper MUST return:
    - `Ok(postcard(R))` on success
    - `Err(Error::Serialization(..))` only for encode/decode failures (tile errors propagate separately via `?` in the generated wrapper).

If decoding fails, the wrapper MUST return `Error::Serialization` with an implementation-defined message.

**Note (implementation detail)**: Raster uses `postcard::from_bytes` and `postcard::to_allocvec` with postcard’s default configuration; Raster does not define an alternate “postcard flavor” or options today.

#### 1.2 Canonical encoding identifier for tile I/O

Raster’s canonical encoding identifier for tile I/O is the UTF-8 string:

- **`"postcard"`**

This identifier is currently:

- Embedded as `ControlFlowSchema.encoding` in CFS (see §3).
- Not embedded in tile artifact manifests (see §4).

---

### 2. Determinism requirements (partially enforced; some GAPs)

Raster’s current implementation uses deterministic codecs (`postcard`, `serde_json`) but does **not** enforce that every Rust type used as a tile input/output serializes deterministically.

Implementers MUST follow these constraints to achieve determinism across machines, toolchains, and runs:

- **Stable type shapes**:
  - Tile input/output types MUST have stable `serde` serialization behavior for the selected encoding (`postcard`).
  - Producers MUST NOT rely on Rust implementation-defined iteration orders when serializing.
- **Maps and sets**:
  - If a tile input/output contains a map-like structure, producers SHOULD use deterministic map types (e.g. `BTreeMap`) rather than hash maps.
  - If a tile input/output contains a set-like structure, producers SHOULD use deterministic set types (e.g. `BTreeSet`).
- **Floating point**:
  - If floating-point values are used, producers MUST treat IEEE754 NaN payload differences and platform-specific computations as potential nondeterminism sources.
  - Raster does not currently normalize floats; therefore, tile authors SHOULD avoid floats for consensus-/proof-critical values.

**GAP (enforcement)**: Raster does not currently validate that tile input/output types are deterministic under `postcard`, and does not provide a “determinism lint” in macros or compilation.

---

### 3. How encoding is recorded in CFS (implemented)

#### 3.1 CFS metadata encoding

The Control Flow Schema (`ControlFlowSchema`) is serialized by tooling as **JSON** via `serde_json`.

- **Rule**: When a tool persists a CFS, it MUST serialize it as UTF-8 JSON.
- **Rule**: Consumers MUST treat the CFS JSON as data-plane metadata only; it is not a tile I/O encoding.

#### 3.2 CFS field `encoding`

`ControlFlowSchema` includes:

- `encoding: String`

Raster tooling currently sets:

- `encoding = "postcard"`

**Meaning**:

- `ControlFlowSchema.encoding` MUST identify the encoding used for **tile ABI input and output bytes** throughout the program described by the CFS, including bytes bound from `InputSource::External`.

**GAP (validation/versioning)**:

- Raster does not currently validate that `encoding` is recognized when consuming a CFS (there is no CFS consumer/executor wired up yet).
- Raster does not currently version the encoding identifier (e.g. `"postcard@1"`), and therefore cannot represent a codec migration in a backwards-compatible way.

#### 3.3 External inputs in the CFS

In the CFS dataflow model, `InputSource::External` indicates that a value is supplied by the runtime environment (not produced by a previous item).

- **Rule**: Any runtime that executes a CFS MUST supply external inputs as **raw bytes** encoded using the codec named by `ControlFlowSchema.encoding`.
- **Rule**: The shape/type of those external inputs is not represented in the current CFS; it is an out-of-band contract between the caller and the tile’s Rust type signature.

**GAP (type information)**: CFS records only arities (`inputs`, `outputs`) and bindings, not Rust types or schemas. There is no machine-checkable way to know what bytes to provide for an external input beyond “must match the tile’s `postcard` decoding”.

---

### 4. How encoding is recorded in manifests/artifacts (partially implemented; GAP)

#### 4.1 Tile artifact manifests (current state)

Tile artifact manifests written to:

- `target/raster/tiles/<tile_id>/<backend>/manifest.json`

currently include fields like:

- `tile_id`
- `backend`
- `method_id` (hex)
- `elf_size`
- (optional) `source_hash` (cache only)

**Rule**: These manifests do not currently record the tile I/O encoding.

**GAP (desired behavior)**: Tile artifact manifests SHOULD record the tile I/O encoding identifier (currently `"postcard"`) and SHOULD include an encoding-version field if/when Raster introduces codec migrations.

#### 4.2 zkVM (RISC0) I/O framing (implemented)

RISC0 execution uses a simple framing convention between host and guest:

- **Host → guest input framing**:
  - The host MUST write a 32-bit unsigned length prefix `L` (little-endian, as used by the RISC0 env writer for `u32`), followed by exactly `L` raw input bytes.
- **Guest input reading**:
  - The guest MUST read the same `u32` length, allocate `L` bytes, then read exactly `L` bytes.
- **Guest output**:
  - The guest MUST commit the tile’s output bytes to the journal exactly as returned by the tile ABI wrapper.

The bytes inside this frame are the canonical tile I/O encoding described in §1 (currently `postcard`).

---

### 5. CLI behavior for external inputs (implemented but currently mismatched; GAP)

The CLI currently accepts `--input <json>` strings for `run` and `preview`, parses them as `serde_json::Value`, and then serializes that `Value` using `postcard`.

- **Current behavior**: `input_bytes = postcard(serde_json::Value)`
- **Tile ABI expectation**: `input_bytes = postcard(T)` where `T` is the tile’s actual Rust parameter type (or tuple)

**GAP (bug / UX mismatch)**: For a tile whose input type is not `serde_json::Value` (e.g. `u64`), the CLI-provided bytes will not decode and execution will fail. There is no implemented JSON→typed conversion layer today.

---

### 6. Examples

#### 6.1 Canonical encoding of a single-arg tile input

Tile:

```rust
#[tile]
fn double(x: u64) -> u64 { x * 2 }
```

Canonical input bytes for `x = 42` MUST be produced as:

```rust
let input: Vec<u8> = postcard::to_allocvec(&42u64).unwrap();
```

and the returned output bytes MUST decode as:

```rust
let y: u64 = postcard::from_bytes(&output_bytes).unwrap();
```

#### 6.2 Canonical encoding of a multi-arg tile input (tuple)

Tile:

```rust
#[tile]
fn add_mul(a: u64, b: u64) -> u64 { (a + b) * 2 }
```

Canonical input bytes MUST be `postcard((a, b))`:

```rust
let input = postcard::to_allocvec(&(1u64, 2u64)).unwrap();
```

#### 6.3 CFS encoding field example

An emitted CFS JSON MUST include:

```json
{
  "version": "1.0",
  "project": "my-project",
  "encoding": "postcard",
  "tiles": [],
  "sequences": []
}
```

