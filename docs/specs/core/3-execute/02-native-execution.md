## Native Execution

This document specifies how Raster executes tiles and sequences **in a native host process** (i.e., as normal Rust code, without a zkVM). It also documents the current implementation status and any known gaps.

### Implementation cross-references (where to look)

- **Tile discovery & invocation ABI**
  - `crates/raster-core/src/registry.rs` (`TILE_REGISTRY`, `TileEntryFn`, `TileRegistration::execute`)
  - `crates/raster-macros/src/lib.rs` (`#[tile]` macro, generated `__raster_tile_entry_*` wrapper)
- **Sequence discovery (native-only convenience)**
  - `crates/raster-macros/src/lib.rs` (`#[sequence]` macro, `SEQUENCE_REGISTRY`)
  - `crates/raster-core/src/registry.rs` (`SEQUENCE_REGISTRY`, `SequenceRegistration`)
- **Backend facade currently used by the runtime**
  - `crates/raster-backend/src/backend.rs` (`Backend`, `ExecutionMode`, `TileExecution`)
  - `crates/raster-backend/src/native.rs` (`NativeBackend` placeholder behavior)
- **Runtime tracing (implemented; execution scheduling is out of scope for runtime today)**
  - `crates/raster-runtime/src/tracing.rs` and `crates/raster-runtime/src/tracing/subscriber/*`
  - `crates/raster-core/src/schema.rs` (`SequenceSchema`, `ControlFlow` types; no schema interpreter in this workspace)
- **Errors**
  - `crates/raster-core/src/error.rs` (`Error`, `Result`)

### Audit checklist for implementers

To verify native execution end-to-end, audit in this order:

- **Tile ABI wrapper**
  - Confirm the wrapper uses `postcard` (not bincode) for input/output.
  - Confirm the wrapper’s error mapping for deserialize/serialize failures.
  - Confirm the wrapper’s behavior for tiles returning `T` vs `Result<T>`.
- **Registry population**
  - Confirm `#[tile]` produces a `linkme` distributed-slice registration on `cfg(all(feature="std", not(target_arch="riscv32")))`.
  - Confirm tile IDs are the Rust function identifier string.
- **Native tile invocation**
  - Confirm the backend/runtime actually calls `registry::find_tile(...).execute(...)`.
  - Confirm how tile inputs are derived (external inputs, previous outputs, tuple packing).
- **Scheduling determinism**
  - Confirm the scheduler has no nondeterministic sources (iteration order over maps/sets, RNG, time, parallelism) unless explicitly specified.
- **Recursion**
  - Confirm how `#[tile(kind = recur)]` is driven: halting condition, max-iterations guard, and how outputs are fed back into the next iteration.
- **Abort/error handling**
  - Confirm the distinction between “tile returned an error” vs “host aborted/panicked”.
  - Confirm what gets recorded in traces (if enabled) on error.

### Definitions

- **Native execution**: executing tiles as host-compiled functions inside the current process.
- **Tile ABI entry**: a function with signature `fn(&[u8]) -> Result<Vec<u8>>` used to invoke a tile using serialized bytes.
- **Tile ID**: the function name string used to identify a tile in the registry.
- **Encoding**: the serialization format used for ABI I/O bytes. In the current codebase this is `postcard`.

### Native tile invocation mechanism

#### Registry and entry function ABI

- The host MUST discover tiles through the global tile registry (`TILE_REGISTRY`).
- Each registry entry provides:
  - Static metadata (tile ID, name, optional description, resource hints)
  - An ABI entry function (`TileEntryFn`) with signature:
    - `fn(&[u8]) -> Result<Vec<u8>>`
- A native runner MUST invoke a tile by:
  - Locating the tile registration by ID (e.g., `find_tile_by_str`).
  - Calling `TileRegistration::execute(input_bytes)`.

#### ABI serialization format (what the wrapper expects)

For host-side invocation through the ABI entry:

- **Encoding**: Inputs and outputs MUST be encoded with `postcard`.
- **Input shape**:
  - If the tile has **0 arguments**, the input bytes are ignored by the wrapper.
  - If the tile has **1 argument** of type `A`, the wrapper MUST deserialize `A` directly from the input bytes.
  - If the tile has **N > 1 arguments** \((A0..AN-1)\), the wrapper MUST deserialize a tuple `(A0, A1, ..., AN-1)` from the input bytes.
- **Output shape**:
  - If the tile returns a plain value `R`, the wrapper MUST serialize `R` to output bytes.
  - If the tile returns `Result<R>`, the wrapper MUST return the tile’s `Err` unchanged, and MUST serialize `R` on `Ok(R)`.

#### Error mapping at the ABI boundary

The generated ABI wrapper MUST produce `raster_core::Error::Serialization(...)` for:

- Failure to deserialize inputs (including type mismatch, malformed bytes).
- Failure to serialize outputs.

The error message text is currently an implementation detail; callers MUST NOT rely on exact wording.

#### Note: outdated “bincode” references (gap)

Some code comments and docstrings currently mention “bincode format” for native tile I/O. The actual implementation generated by `#[tile]` uses `::raster::core::postcard::{from_bytes,to_allocvec}` and the CFS encoding default is `"postcard"`. Any mention of “bincode” in the native ABI should be treated as stale documentation.

### Deterministic scheduling (native)

Native execution is intended to be deterministic with respect to:

- **Tile ordering**: A given schedule MUST execute tiles in a well-defined order.
- **Input derivation**: For any executed tile, its input bytes MUST be derived only from:
  - The sequence’s external inputs, and/or
  - Outputs of prior items, and/or
  - Constants embedded in the schedule (if supported by the scheduler).

#### Current implementation status (gap)

As of this revision:

- There is **no runtime scheduler** in this workspace that interprets `SequenceSchema`/`ControlFlow` to execute sequences end-to-end.
- Therefore, deterministic scheduling rules above define the required behavior for a future native runner, but are not yet exercised by the shipped runtime crate.

### Recursion and iteration driving rules

Raster has a notion of “recursive tiles” (`#[tile(kind = recur)]`), and the authoring surface indicates a special halting condition (“until its first output returns true”).

#### Required behavior (intended)

When a schedule invokes a recursive tile in “recursive mode”, the runner SHOULD execute it repeatedly as follows:

- **Initial state**: The first invocation takes the scheduled input(s) as usual.
- **Iteration**:
  - On each iteration, the runner invokes the tile with the current state input bytes.
  - The tile produces output bytes which are deserialized into the tile’s declared output type(s).
- **Halting**:
  - The runner stops iterating when the tile’s “done” flag is `true`.
  - The “done” flag is defined as: the **first output value** of the tile (output index 0) interpreted as `bool` MUST be `true`.
- **Next-state**:
  - If the tile returns multiple outputs, the runner SHOULD treat the remaining output values (outputs 1..N-1) as the next iteration’s state inputs (by re-serializing them according to the tile’s input type).
  - If the tile returns a single output `(done: bool)`, the runner SHOULD treat the next-state as unit/empty (and MUST halt immediately if it cannot derive the next input).
- **Safety guard**:
  - The runner SHOULD enforce a maximum iteration bound (configurable), and MUST abort with an error if the bound is exceeded.

#### Current implementation status (gap)

As of this revision:

- `#[tile(kind = recur)]` generates a Rust `macro_rules!` macro to enable `tile_name!(...)` syntax in user code, but **no runtime component** currently interprets this as recursion driving logic.
- Neither `NativeBackend` nor any schema-driven runtime runner in this workspace currently implements iterative invocation, halting checks, or max-iteration enforcement.

### Handling of errors and aborts

#### Tile-level errors

- If a tile returns `Result<R>` and yields `Err(e)`, the runner MUST treat this as a tile execution failure and MUST stop executing the current schedule.
- If a tile’s ABI wrapper fails to deserialize input or serialize output, the runner MUST treat this as a tile execution failure and MUST stop executing the current schedule.

#### Host aborts (panic)

- If a tile panics during native execution, the behavior is currently unspecified by the runtime.
- A production-quality native runner SHOULD catch panics at the tile boundary (if possible) and convert them into `Error::Other(...)`, including enough context to identify the tile ID.

#### Backend-level behavior in this repository (current)

The native backend implementation in this repository currently behaves as follows:

- If executed in a mode that generates proofs, it returns an error:
  - `Error::Other("Native backend does not support proof generation. Use the RISC0 backend.")`
- Otherwise, it does **not execute the tile** and returns a placeholder `TileExecution` whose:
  - `output` is `Vec::new()`
  - `cycles` is a simulated constant (1000 by default, or 0 if cycle simulation is disabled)

This means:

- Native backend “execution” currently MUST NOT be relied on to run user tiles.
- Any “native execution” that actually runs tiles today MUST be performed by calling registered tile functions directly (or via the registry ABI), not through `NativeBackend::execute_tile`.

#### CLI behavior (current)

The CLI provides:

- `cargo raster run` (whole-program native run): builds and runs the user binary as a subprocess (not a schema interpreter).
- `cargo raster run-tile --backend native` (tile-level native backend): uses `NativeBackend::execute_tile`, which is currently a placeholder and does not execute via the registry.

### Examples

#### Example: ABI input/output shapes

Given:

- `#[tile] fn add_one(x: u64) -> u64`
  - Input bytes MUST be `postcard(add_one_input)` where `add_one_input` is a `u64`.
  - Output bytes are `postcard(u64)`.

- `#[tile] fn add(x: u64, y: u64) -> u64`
  - Input bytes MUST be `postcard((x, y))` (a tuple), not two concatenated `postcard` values.

#### Example: sequence registration vs execution

Given:

- `#[sequence] fn main(name: String) -> String { ... }`

Then:

- The sequence MUST be discoverable via `SEQUENCE_REGISTRY` in host builds that enable `std`.
- Executing a sequence through a schema-driven runtime runner is currently a gap (no such runner exists in this workspace today).

