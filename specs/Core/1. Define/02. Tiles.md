## Tiles

Tiles are the smallest executable units in Raster. A tile is authored as a Rust free function annotated with `#[tile(...)]`. Raster tooling generates a stable byte-level ABI wrapper for each tile, and (in host builds) registers tile metadata in a global registry for discovery and invocation.

This document describes the tile authoring rules and the tile ABI contract as implemented today, including known gaps where the current code does not yet enforce or represent the intended behavior.

## Code audit tasks (where to look)

- **Tile macro implementation**
  - `crates/raster-macros/src/lib.rs`
    - `TileAttrs::parse` (attribute parsing rules; required `iter`/`recur`)
    - `tile` proc-macro (ABI wrapper generation, `Result` handling, and optional recursion macro emission)
    - Naming: `__raster_tile_entry_<fn_name>` wrapper convention
- **Core tile types**
  - `crates/raster-core/src/tile.rs` (`TileId`, `TileMetadata`, and their `*_Static` forms)
  - `crates/raster-core/src/error.rs` (`Error::Serialization` and propagation behavior)
  - `crates/raster-core/src/lib.rs` (re-export of `postcard` and `no_std`/`alloc` posture)
- **Host-side registry (std-only, non-RISC-V)**
  - `crates/raster-core/src/registry.rs`
    - `TileEntryFn` signature (`fn(&[u8]) -> Result<Vec<u8>>`)
    - `TileRegistration::execute`
    - `TILE_REGISTRY` distributed slice + `find_tile_by_str`
- **Compiler-side discovery and representation**
  - `crates/raster-compiler/src/discovery.rs`
    - `TileDiscovery` (source scanning and inferred `tile_type`)
    - `SequenceDiscovery` and `SequenceCall::is_recursive` (recognizes `callee!(` textual suffix)
  - `crates/raster-compiler/src/cfs_builder.rs` and `crates/raster-core/src/cfs.rs`
    - `TileDef { type: "iter" | "recur", inputs, outputs }`
    - Note: `is_recursive` is currently not propagated into CFS items (gap)
- **zkVM integration (RISC0)**
  - `crates/raster-backend-risc0/src/guest_builder.rs`
    - Guest `main` reads `u32` length then raw input bytes
    - Guest calls the tile ABI wrapper directly and commits the raw output bytes
  - `crates/raster-backend-risc0/src/risc0.rs`
    - Host writes `u32` length + raw bytes into the environment
    - Host reads output bytes from the journal

## Tile definition rules

### Declaring a tile

A tile MUST be declared by applying the `#[tile(...)]` attribute to a Rust free function:

- The tile attribute MUST specify a tile kind as its first argument: `iter` or `recur`.
  - Valid: `#[tile(iter)]`, `#[tile(recur)]`
  - Invalid: `#[tile]` (this is rejected by the macro; see “Known gaps” for compiler discovery behavior)
- The macro MAY accept optional key/value metadata:
  - `description = "..."` (string)
  - `estimated_cycles = N` (u64)
  - `max_memory = N` (u64 bytes)

The tile’s **tile id** is the Rust function identifier string, as written in source (e.g., `double`, `hash_leaf`). The macro uses this string for both `TileMetadataStatic::id` and `TileMetadataStatic::name`.

Tiles SHOULD use globally-unique function names within the compilation unit where they are linked, because the host registry is keyed only by this id string.

### Signature restrictions

To be ABI-compatible with the current macro-generated wrapper, a tile function MUST satisfy all of the following:

- **Free function**: The function MUST NOT have a `self` receiver.
- **Non-generic**: The function MUST NOT be generic (type parameters and/or `where` clauses that introduce generics). The wrapper is monomorphic and cannot supply generic arguments.
- **Serde-compatible I/O types**:
  - Each input type MUST be deserializable via `postcard::from_bytes`.
  - The return type MUST be serializable via `postcard::to_allocvec`.
  - Practically, this means the input and output types SHOULD derive `serde::Deserialize`/`serde::Serialize`.
- **`Result` returns (optional)**:
  - A tile MAY return a `Result<T, raster_core::Error>` (or the `raster::core::Result<T>` alias).
  - If the macro detects the return type name as `Result`, the wrapper uses `?` to propagate errors.
  - To compile successfully, the tile’s error type MUST match `raster_core::Error` (or be convertible into it via `From`, which is not broadly implemented today).

### `no_std` and determinism constraints

- Tiles intended to run in the RISC0 guest MUST compile in a `#![no_std]` context with `alloc` available (the guest builder depends on the user crate with `default-features = false`).
- Tiles intended to be proven/verified SHOULD be deterministic and free of host-side nondeterminism (I/O, system time, randomness, threads, environment variables). Raster does not currently enforce “purity”; this is an implementer responsibility.

## Tile ABI wrapper and encoding contract

For every `#[tile(...)] fn <name>(...) -> ...` declaration, the macro generates a public ABI wrapper function:

- Name: `__raster_tile_entry_<name>`
- Signature: `pub fn __raster_tile_entry_<name>(input: &[u8]) -> raster_core::Result<alloc::vec::Vec<u8>>`

This wrapper is the cross-backend execution entry point:

- Host registry execution (`TileRegistration::execute`) calls this wrapper.
- RISC0 guest programs call this wrapper directly.

### Input encoding

The `input: &[u8]` MUST be a postcard encoding of the tile’s arguments, determined by arity:

- **0 arguments**: `input` MUST be `postcard`-encoded `()`.
- **1 argument**: `input` MUST be `postcard`-encoded value of that argument type.
- **2+ arguments**: `input` MUST be `postcard`-encoded tuple of all arguments in declaration order.

Examples:

- If the tile is `fn f() -> u64`, `input` is `postcard::to_allocvec(&())`.
- If the tile is `fn f(x: u64) -> u64`, `input` is `postcard::to_allocvec(&x)`.
- If the tile is `fn f(x: u64, y: u64) -> u64`, `input` is `postcard::to_allocvec(&(x, y))`.

### Output encoding

On success, the wrapper MUST return `Ok(output_bytes)` where `output_bytes` is the postcard encoding of the tile’s return value.

- If the tile returns `()`, the output is the postcard encoding of `()`.
- If the tile returns a tuple, the output is the postcard encoding of that tuple.

### Error behavior

- If input deserialization fails, the wrapper MUST return `Err(raster_core::Error::Serialization(...))`.
- If output serialization fails, the wrapper MUST return `Err(raster_core::Error::Serialization(...))`.
- If the tile returns `raster_core::Result<T>` and returns an `Err(e)`, the wrapper MUST propagate that error via `?` (no wrapping).

## Tile kinds: iterative vs recursive

Raster distinguishes tile “kinds” via the first `#[tile(...)]` argument:

- **Iterative tiles (`iter`)**: standard tiles that execute once per call.
- **Recursive tiles (`recur`)**: tiles intended to be executed repeatedly until a termination condition is reached.

Today, tile kind is represented as a string value (`"iter"` or `"recur"`) in compiler-discovered metadata and in the generated CFS `TileDef.type`. The runtime ABI wrapper is identical for both kinds.

### Recursive invocation marker (`!`) and ABI wrapper

For `#[tile(recur)]` tiles, the macro also emits a `macro_rules!` macro of the same name so user code can write `tile_name!(args)`:

- In native Rust semantics, `tile_name!(args)` expands to `tile_name(args)`.
- In compiler source discovery, a callee name ending with `!` (e.g., `count_to!(...)`) is recognized as “recursive invocation”.

### Recursion step contract (intended; partially implemented)

When a recursive tile is invoked in “recursive mode”, the system is expected to repeatedly execute the tile as long as it indicates it is not finished. The current macro documentation implies:

- The recursive tile’s **first output value** indicates termination (“run until its first output returns true”).

To make that interoperable at the byte level, recursive tiles SHOULD follow this convention:

- A recursive tile SHOULD return a tuple whose first element is a `bool` named conceptually `done`.
- The remaining element(s) SHOULD contain the next-step state, and MUST be sufficient to re-invoke the tile again.

Example convention:

- Input type: `State`
- Output type: `(bool, State)` where:
  - `done == false` indicates “continue”, and the next invocation uses the returned `State`
  - `done == true` indicates “stop”, and the returned `State` is the final state

Known gaps (current behavior):

- The compiler’s CFS representation does not currently encode recursion steps, termination, or re-invocation wiring. `SequenceCall::is_recursive` is parsed from source text but is not propagated into `raster_core::cfs::SequenceItem`, and no executor implements recursive looping yet.
- The macro does not validate that a `#[tile(recur)]` function returns a tuple whose first element is `bool`.
- As a result, “recursive execution” is currently a syntactic marker and metadata label, not an enforced runtime behavior.

## Examples

### Iterative tile example (single input)

```rust
use raster::prelude::*;
use serde::{Deserialize, Serialize};

#[tile(iter, description = "Doubles a number", estimated_cycles = 1000)]
fn double(x: u64) -> u64 {
    x * 2
}

fn host_call_via_abi() -> raster::core::Result<u64> {
    // Encode input as postcard(u64) because this tile takes exactly one argument.
    let input = raster::core::postcard::to_allocvec(&21u64).unwrap();

    // Call the generated ABI wrapper.
    let output = __raster_tile_entry_double(&input)?;

    // Decode output as postcard(u64).
    let y: u64 = raster::core::postcard::from_bytes(&output).unwrap();
    Ok(y)
}
```

### Recursive tile example (state machine)

This example follows the intended `(done, next_state)` convention. Note that recursive looping is not yet implemented end-to-end; this shows the authoring pattern and ABI shape.

```rust
use raster::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
struct Counter {
    current: u64,
    goal: u64,
}

#[tile(recur, description = "Counts up to a goal")]
fn count_to(state: Counter) -> (bool, Counter) {
    if state.current >= state.goal {
        return (true, state);
    }

    (
        false,
        Counter {
            current: state.current + 1,
            goal: state.goal,
        },
    )
}

fn one_step_via_abi() -> raster::core::Result<(bool, Counter)> {
    let state = Counter { current: 0, goal: 3 };
    let input = raster::core::postcard::to_allocvec(&state).unwrap();
    let output = __raster_tile_entry_count_to(&input)?;
    let step: (bool, Counter) = raster::core::postcard::from_bytes(&output).unwrap();
    Ok(step)
}

// Authoring marker for recursive invocation:
// `count_to!(state)` expands to `count_to(state)` at Rust runtime, but is detected
// as a recursive call by compiler-side source discovery.
fn authoring_marker_example(state: Counter) -> (bool, Counter) {
    count_to!(state)
}
```

## Known gaps and divergences (code vs desired behavior)

- **`#[tile]` without arguments**
  - The proc macro rejects empty attributes (it panics at compile time and requires `iter` or `recur`).
  - The compiler’s source discovery currently accepts `#[tile]` and defaults the discovered type to `"iter"`.
  - Tooling SHOULD be updated to align (either reject `#[tile]` in discovery or make the macro accept a default).
- **Encoding comments that mention bincode**
  - Several host-side comments (e.g., in `raster_core::registry` and `raster_backend::Backend`) mention “bincode”, but the tile ABI wrapper uses `postcard` for input/output encoding.
  - Implementations MUST treat the tile ABI encoding as postcard unless and until a versioned encoding switch is introduced.
- **Recursive execution**
  - Recursive invocation is detected in source discovery via the `!` suffix but is not yet represented in the generated CFS and is not implemented in any executor backend.
  - Any “recursive step contract” described above is therefore a convention for future compatibility rather than behavior enforced today.
