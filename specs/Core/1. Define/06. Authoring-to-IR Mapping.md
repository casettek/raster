## Overview

This document specifies how Raster authoring constructs in Rust source code map to the internal intermediate representations used by the current Raster toolchain, and how that representation lowers into the Control Flow Schema (CFS).

This spec is written to match the code as it exists today. Where the implementation is incomplete or fails to preserve important information (e.g., determinism, recursion markers), those gaps are explicitly called out.

## Code audit tasks (where to look)

- **Macro authoring surface (compile-time registration)**:
  - `crates/raster-macros/src/lib.rs`
    - `#[tile(...)]` macro expands:
      - ABI wrapper `__raster_tile_entry_<fn>`
      - `linkme` registration in `raster_core::registry::TILE_REGISTRY` (host-only cfg gate)
      - (for `recur`) a `macro_rules! <tile_name> { ... }` wrapper enabling `<tile_name>!(...)` syntax
    - `#[sequence(...)]` macro expands:
      - `linkme` registration in `raster_core::registry::SEQUENCE_REGISTRY`
      - extracts a *flat list of call identifiers* using a `syn` visitor (no bindings, no dataflow)

- **Actual IR used by the CLI/compiler today (source-scanned, not macro output)**:
  - `crates/raster-compiler/src/discovery.rs`
    - `DiscoveredTile`
    - `DiscoveredSequence`
    - `SequenceCall`
    - `TileDiscovery` and `SequenceDiscovery` (line-based parsing)
  - `crates/raster-compiler/src/flow_resolver.rs`
    - `FlowResolver` (binds arguments to `InputSource`)
  - `crates/raster-compiler/src/cfs_builder.rs`
    - `CfsBuilder` (lowers discovered+resolved structures into `raster_core::cfs::ControlFlowSchema`)

- **CFS types and serialization shape**:
  - `crates/raster-core/src/cfs.rs`
    - `ControlFlowSchema`, `TileDef`, `SequenceDef`, `SequenceItem`, `InputBinding`, `InputSource`
  - `crates/raster-cli/src/commands.rs`
    - `cfs()` command: serializes CFS to JSON via `serde_json::to_string_pretty`

## Scope and terms

- **Authoring**: User-authored Rust code in their project’s `src/` tree.
- **Tile**: A Rust function annotated with `#[tile(...)]`.
- **Sequence**: A Rust function annotated with `#[sequence(...)]`.
- **Discovery IR**: The structures obtained by scanning/parsing Rust source text (`DiscoveredTile`, `DiscoveredSequence`, `SequenceCall`).
- **Resolved IR**: The per-sequence items where each call argument is mapped to an input source (`raster_core::cfs::SequenceItem` + `InputBinding`).
- **CFS**: The final schema object (`raster_core::cfs::ControlFlowSchema`) emitted by the compiler/CLI.

## Authoring constructs

### Tiles (`#[tile(...)]`)

A tile is authored as a Rust function annotated with `#[tile(...)]`.

- A tile attribute invocation MUST start with `#[tile`.
- The implementation recognizes tile types:
  - `iter`
  - `recur`
- A tile MAY include optional attributes:
  - `estimated_cycles = <u64>`
  - `max_memory = <u64>`
  - `description = "<string>"`

**Current implementation note**: the CLI/compiler does not evaluate macro expansions for discovery; it scans source text looking for a line starting with `#[tile` and then associates it with the next `fn`/`pub fn` signature line. Multi-line signatures are not fully supported for arity counting (see “Gaps”).

### Sequences (`#[sequence(...)]`)

A sequence is authored as a Rust function annotated with `#[sequence(...)]`.

- A sequence attribute invocation MUST start with `#[sequence`.
- The implementation optionally supports:
  - `description = "<string>"`

The current toolchain models sequences as an ordered list of calls found in the function body.

## Intermediate representations

### Discovery IR (compiler/CLI)

Discovery IR is produced by scanning the project’s `src/` directory recursively.

#### `DiscoveredTile`

The compiler constructs a `DiscoveredTile` with the following fields (implementation: `crates/raster-compiler/src/discovery.rs`):

- **metadata.id**: The tile identifier as a string, currently equal to the Rust function name.
- **metadata.name**: Human-readable name, currently equal to the Rust function name.
- **metadata.description**: Optional string from `description="..."` if present.
- **metadata.estimated_cycles**: Optional `u64` from `estimated_cycles=...` if present.
- **metadata.max_memory**: Optional `u64` from `max_memory=...` if present.
- **source_file**: Path to the Rust source file where the tile was found.
- **line_number**: 1-based line number of the function definition line.
- **input_count**: Number of inputs inferred from the function signature line.
- **output_count**: Number of outputs inferred from the function signature line (`0` for unit, tuple arity for tuples, otherwise `1`).
- **tile_type**: `"iter"` or `"recur"` (default `"iter"` if not provided or not parseable by discovery).

#### `DiscoveredSequence`

The compiler constructs a `DiscoveredSequence` with the following fields:

- **id**: The sequence identifier as a string, currently equal to the Rust function name.
- **name**: Human-readable name, currently equal to the Rust function name.
- **description**: Optional string from `description="..."` if present.
- **param_names**: Ordered list of parameter names, extracted from the function signature line.
- **input_count**: The number of parameters (`param_names.len()`).
- **calls**: Ordered list of `SequenceCall` extracted from the function body.
- **source_file**: Path to the Rust source file where the sequence was found.
- **line_number**: 1-based line number of the function definition line.

#### `SequenceCall`

Each call in `DiscoveredSequence.calls` is represented as:

- **callee**: The identifier of the called function/macro (string).
- **result_binding**: Optional variable name bound by a `let` statement. If present, it is treated as receiving output index 0.
- **arguments**: Vector of argument strings, derived by splitting the text inside the outermost `(...)`.
- **is_recursive**: Boolean, derived by whether the callee ends in `!` (e.g., `count_to!(...)`).

### Resolved IR (dataflow resolution)

For each discovered sequence, the compiler resolves call arguments into input sources, producing a list of `raster_core::cfs::SequenceItem` records (implementation: `crates/raster-compiler/src/flow_resolver.rs`).

Each item has:

- **item_type**: `"tile"` or `"sequence"`.
- **item_id**: callee identifier.
- **input_sources**: list of `InputBinding`, one per argument, where each binding wraps an `InputSource`:
  - `external`
  - `seq_input { input_index }`
  - `item_output { item_index, output_index }`

## Lowering rules (authoring → discovery IR)

### Source traversal

- The compiler MUST scan the project’s `src/` directory.
- It MUST consider files with the `.rs` extension.
- It MUST traverse into subdirectories recursively.

**Gap (determinism)**: the current implementation uses `std::fs::read_dir` without sorting paths. The resulting traversal order is platform/filesystem dependent, so the order of discovered tiles/sequences MAY differ across machines or runs.

### Tile discovery

When scanning a file:

- If a trimmed line starts with `#[tile`, the compiler MUST parse attributes from that line only.
- The compiler MUST associate the attribute with the next subsequent non-empty, non-comment, non-attribute line that begins with `fn ` or `pub fn `.
- The tile ID MUST be the function name extracted from that signature line.
- `tile_type` MUST be `"iter"` or `"recur"` if present in the attribute’s first argument; otherwise it defaults to `"iter"` (discovery fallback).
- `input_count` MUST be computed by counting top-level commas in the argument list in the signature line.
- `output_count` MUST be computed from the signature line:
  - If no `->` is present, outputs MUST be `0`
  - If the return type is exactly `()`, outputs MUST be `0`
  - If the return type appears to be a tuple, outputs SHOULD be the tuple arity
  - Otherwise outputs MUST be `1`

**Gap (multi-line signatures)**: argument and return counting are based on a single line. Signatures spanning multiple lines may be miscounted.

### Sequence discovery

When scanning a file:

- If a trimmed line starts with `#[sequence`, the compiler MUST parse attributes from that line only.
- The compiler MUST associate the attribute with the next subsequent non-empty, non-comment, non-attribute line that begins with `fn ` or `pub fn `.
- The sequence ID MUST be the function name extracted from that signature line.
- `param_names` MUST be extracted by parsing the text between `(` and `)` on that same signature line and taking the token before each `:` (with an optional `mut ` prefix stripped).
- The sequence body MUST be scanned line-by-line to find calls.

**Gap (async and complex signatures)**: `async fn` signatures do not match `fn `/`pub fn ` and will not be discovered.

### Call extraction rules inside sequences

The compiler currently extracts calls using line-based heuristics:

- It recognizes `let <binding> = <callee>(<args>);`
  - `<binding>` becomes `result_binding = Some(binding)`
  - `<callee>` becomes `callee`
- It recognizes bare expression calls of the form `<callee>(<args>)` (including return expressions)
  - `result_binding = None`
- It sets `is_recursive = true` if the callee token ends with `!` (e.g., `count_to!(...)`).
- It MUST ignore:
  - calls where the callee contains `::` (paths) or `.` (method calls)
  - a fixed exclude list of common names (e.g., `println`, `format`, `Some`, `Ok`, etc.)

Arguments are parsed by splitting on commas at “top level” with limited nesting support:

- parentheses nesting `(...)` and generic angle brackets `<...>` are tracked to avoid splitting inside them.
- the raw argument text is preserved as strings (e.g., `"0"`, `"x + 1"`, `"foo(bar)"`).

**Gap (structural correctness)**: this is not a Rust parser. Multi-line calls, complex formatting, and control-flow constructs can lead to missed calls or mis-parsed arguments.

## Lowering rules (discovery/resolved IR → CFS)

### Tile lowering

Each `DiscoveredTile` lowers to one `TileDef`:

- `TileDef.id` MUST be `DiscoveredTile.metadata.id.0`
- `TileDef.type` MUST be `DiscoveredTile.tile_type`
- `TileDef.inputs` MUST be `DiscoveredTile.input_count`
- `TileDef.outputs` MUST be `DiscoveredTile.output_count`

### Sequence lowering

Each `DiscoveredSequence` lowers to one `SequenceDef`:

- `SequenceDef.id` MUST be `DiscoveredSequence.id`
- `SequenceDef.input_sources` MUST contain exactly `input_count` bindings, each `external`
- `SequenceDef.items` MUST be the ordered list of resolved `SequenceItem` values produced by dataflow resolution

### Item typing

For each `SequenceCall`:

- If `callee` matches a known discovered tile ID, `item_type` MUST be `"tile"`.
- Else if `callee` matches a known discovered sequence ID, `item_type` MUST be `"sequence"`.
- Else `item_type` defaults to `"tile"`.

### Dataflow resolution (argument binding)

For a given sequence:

- A mapping `param_indices` is constructed from `param_names[i] -> i`.
- A mapping `bindings` is constructed as the sequence is processed left-to-right:
  - if a call has `result_binding = Some(name)`, then `bindings[name] = (item_index, 0)`

For each argument string `arg` in a call’s `arguments`, the compiler binds it as:

- If `arg` matches a parameter name in `param_indices`, it MUST produce `seq_input { input_index }`.
- Else if `arg` matches a previous `result_binding` in `bindings`, it MUST produce `item_output { item_index, output_index }`.
- Else it MUST produce `external`.

**Gaps (dataflow fidelity)**:

- Only output index `0` is used for bindings, even if a tile returns a tuple.
- Literals and complex expressions are treated as `external` rather than “constant” inputs.

### Recursive calls

The discovery IR records a boolean `is_recursive` for `callee!(...)` syntax.

**Gap (recursion not represented in CFS)**: the current CFS types (`raster_core::cfs`) and lowering (`CfsBuilder`/`FlowResolver`) do not preserve recursion markers. As a result, the emitted CFS cannot distinguish `foo!(...)` from `foo(...)` beyond tile metadata `type = "recur"` (and even that is independent of `is_recursive`).

## Determinism, ordering, and canonicalization

### Ordering rules that are intended

To ensure reproducible outputs, a canonicalized CFS SHOULD be derived with:

- `cfs.tiles` sorted lexicographically by `TileDef.id`
- `cfs.sequences` sorted lexicographically by `SequenceDef.id`
- within each sequence, `SequenceDef.items` MUST preserve the authoring order (left-to-right within the sequence body)
- within each item, `input_sources` MUST preserve the argument order of the call

### Current implementation behavior (non-canonical)

- Discovery order depends on:
  - filesystem traversal order (`read_dir` without sorting)
  - file ordering encountered by traversal
- `cfs.tiles` is emitted in discovery order.
- `cfs.sequences` is emitted in discovery order.
- The CLI writes JSON using pretty-printing (`serde_json::to_string_pretty`), which is not a canonical byte encoding.

If a consumer needs stable hashing or identity over CFS content, it MUST apply a deterministic normalization (e.g., sorting as above and then using a canonical encoding as specified elsewhere).

## Error cases

Discovery/building may fail with:

- **Missing `src/` directory**: discovery MUST return an error.
- **I/O failures**: discovery MUST return an error.
- **Parse failures**: the current implementation is best-effort; malformed attribute lines or signatures may result in missing tiles/sequences rather than hard errors.

## Examples

### Example authoring

```rust
use raster::prelude::*;

#[tile(iter, description = "Greets")]
fn greet(name: String) -> String {
    format!("Hello, {name}!")
}

#[tile(recur, description = "Counts until done")]
fn count_to(state: (u64, u64)) -> (u64, u64) {
    state
}

#[sequence(description = "Main flow")]
fn main(name: String) -> String {
    let greeting = greet(name);
    // recursion marker syntax in authoring:
    let _ = count_to!((0, 10));
    greeting
}
```

### Expected discovery IR (shape)

- `DiscoveredTile` for `greet`
  - `tile_type = "iter"`, `inputs = 1`, `outputs = 1`
- `DiscoveredTile` for `count_to`
  - `tile_type = "recur"`, `inputs = 1`, `outputs = 2` (tuple arity, if detected from the signature line)
- `DiscoveredSequence` for `main`
  - `param_names = ["name"]`
  - `calls` (in order):
    - `SequenceCall { callee: "greet", result_binding: Some("greeting"), arguments: ["name"], is_recursive: false }`
    - `SequenceCall { callee: "count_to", result_binding: Some("_"), arguments: ["(0, 10)"], is_recursive: true }`

### Expected CFS (informative JSON shape)

The CLI emits JSON for `ControlFlowSchema`. The relevant structure looks like:

```json
{
  "version": "1.0",
  "project": "<from Cargo.toml>",
  "encoding": "postcard",
  "tiles": [
    { "id": "greet", "type": "iter", "inputs": 1, "outputs": 1 }
  ],
  "sequences": [
    {
      "id": "main",
      "input_sources": [{ "source": { "type": "external" } }],
      "items": [
        {
          "item_type": "tile",
          "item_id": "greet",
          "input_sources": [{ "source": { "type": "seq_input", "input_index": 0 } }]
        }
      ]
    }
  ]
}
```

**Gap reminder**: the `count_to!` recursion marker is not represented in current CFS output, and bindings only reference output index 0.

## Known gaps and follow-ups

- Implement deterministic discovery ordering (sort directory entries and/or sort final `tiles`/`sequences` lists before emitting CFS).
- Preserve recursion markers in the resolved IR and CFS (requires extending `raster_core::cfs` types and the lowering).
- Replace line-based discovery with a Rust parser (or reuse macro-produced metadata) to accurately handle multi-line signatures, control flow, method calls, and paths.
- Extend dataflow bindings to support tuple outputs (`output_index > 0`) and destructuring bindings.
