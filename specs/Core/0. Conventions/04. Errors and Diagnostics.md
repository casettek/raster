## Errors and Diagnostics

This document specifies **how Raster represents, classifies, and surfaces failures** across the Core library and toolchain (compiler, runners/backends, and macros).

Raster’s current implementation is intentionally minimal: **most failures are surfaced as human-readable strings**, with only a small number of structured error variants in `raster-core`. Where the spec below defines additional structure that the code does not yet provide, it is explicitly labeled as a **GAP**.

### Code audit tasks (where to look)

- **Core error type (public, `no_std`-compatible)**: `crates/raster-core/src/error.rs`
  - `pub enum Error` and `pub type Result<T>`.
- **Tile ABI wrapper error mapping (serialization/deserialization)**: `crates/raster-macros/src/lib.rs`
  - `#[tile]` generates `__raster_tile_entry_*` returning `raster::core::Result<Vec<u8>>`.
  - Input/output (de)serialization uses `postcard` and maps failures to `Error::Serialization(...)`.
  - Macro argument validation uses `panic!` (compile-time panic), not structured diagnostics.
- **CLI surface area (user-facing messages and “stringly” errors)**: `crates/raster-cli/src/commands.rs`
  - Uses `anyhow` for top-level errors and adds context in a few places.
  - Some IO/hex decode failures are swallowed via `unwrap_or_default()` (see “GAPs”).
- **Compiler/discovery failures (source scanning, caching, manifests)**:
  - `crates/raster-compiler/src/discovery.rs` (tile + sequence source scanning)
  - `crates/raster-compiler/src/builder.rs` (build orchestration, cache invalidation, manifest writing)
- **Backend/runner failure modes**:
  - Backend trait: `crates/raster-backend/src/backend.rs` (`Backend`, `ExecutionMode`, `TileExecution`)
  - Native backend: `crates/raster-backend/src/native.rs`
  - RISC0 backend (zkVM integration): `crates/raster-backend-risc0/src/risc0.rs`
  - RISC0 guest builder errors: `crates/raster-backend-risc0/src/guest_builder.rs` (`GuestBuildError`)

### Terminology

- **Error**: A failure represented as a value (returned in `Result::Err`) intended for programmatic propagation.
- **Diagnostic**: A user-facing explanation of a failure (often rendered as text) that may include context (tile id, file path, phase).
- **Host**: The “outside” environment running Raster tooling (CLI process, filesystem, compiler toolchain, zkVM host APIs).
- **Guest**: The zkVM program executing the tile.

### Error taxonomy

Raster failures MUST be classifiable along these axes:

- **Surface (who sees it)**:
  - **User-facing**: errors intended to be shown to the developer/operator (CLI output; returned from public APIs with stable meaning).
  - **Internal**: errors used for control flow or debugging; not intended to be relied upon by downstream users.
- **Trust domain (where it occurred)**:
  - **Verifiable failure**: failure that occurs **inside the guest computation** or is **cryptographically checkable** from verifiable artifacts (e.g., receipt verification fails).
  - **Host failure**: failure caused by the host environment (IO, toolchain missing, subprocess execution, configuration, deserialization of host-provided inputs, etc.).

#### Required classification rules

An implementation MUST classify failures as follows:

- **Host failure**:
  - IO errors (read/write files, create dirs), missing toolchains, subprocess failures, environment misconfiguration.
  - Failures to build a zkVM executor/prover environment.
  - Failures to deserialize/serialize artifacts **on the host** (e.g., receipt bytes).
- **Verifiable failure**:
  - Any failure that occurs during execution of the guest program (including guest panics/aborts).
  - Proof verification failures (receipt invalid for method id).

**GAP (current code):** Raster does not currently encode this classification in a structured form. Most of these are returned as `raster_core::Error::Other(String)` (or `anyhow::Error` in the CLI), without an explicit “host vs verifiable” tag.

### Current error representation (as implemented)

#### `raster-core` public error type

The canonical error type exposed by the Core crate is:

- `raster_core::Error` (in `crates/raster-core/src/error.rs`) with variants:
  - `InvalidTileId(String)`
  - `InvalidSequence(String)`
  - `Serialization(String)`
  - `Io(std::io::Error)` (only when built with `std`)
  - `Other(String)`

Requirements:

- **Core APIs that are part of Raster’s stable surface** SHOULD return `raster_core::Result<T>`.
- When `std` is enabled, implementations MUST preserve IO error source chains when possible (e.g., via `Error::Io` or equivalent).
- `Error::Other(String)` MUST be treated as **non-stable** and **non-machine-readable** by downstream consumers.

**GAP:** There are no stable error codes, no structured diagnostic payloads, and no error “phase” information in `raster_core::Error`.

#### Procedural macro failures (`#[tile]`, `#[sequence]`)

Required behavior:

- Macros MUST reject invalid macro invocations at compile time.
- Macro-reported errors SHOULD be emitted as normal Rust compiler diagnostics (span-aware) rather than panicking.

Current behavior:

- `#[tile]` **panics** if:
  - the attribute is empty (requires a type argument like `iter` or `recur`);
  - the first attribute argument is not `iter` or `recur`.
- `#[tile]` maps runtime serialization/deserialization failures into:
  - `Error::Serialization("Failed to deserialize input: ...")`
  - `Error::Serialization("Failed to serialize output: ...")`
- If a tile function is detected as “returning `Result`” (string match on the last path segment), the generated wrapper uses `?`.
  - This means a tile returning `Result<T, E>` MUST have an error type that can be converted into `raster_core::Error`, or compilation will fail with a Rust type error.

**GAP:** Macro panics are not structured diagnostics and may not provide precise spans. This is a known divergence from ideal implementer ergonomics.

#### Discovery / compilation pipeline errors

Source scanning (`raster-compiler`):

- `TileDiscovery::discover()` and `SequenceDiscovery::discover()` return `raster_core::Result<...>`.
- Missing `src/` directory returns `Error::Other("Source directory not found: ...")`.
- Filesystem traversal and file reads map to `Error::Io` (when `std` is enabled).

Build orchestration (`Builder`):

- Tile compilation errors from a backend MAY be logged as warnings and the build MAY continue for other tiles.
  - Concretely, `Builder::build_from_source()` prints:
    - `Warning: Failed to compile tile '...': ...`
    - and continues building remaining tiles.
- Cache behavior:
  - Missing/invalid manifest or source hash causes recompilation (treated as cache miss).
  - Manifest serialization errors map to `Error::Serialization(...)`.

**GAP:** “Partial success” is currently unstructured (warnings printed to stderr); there is no machine-readable list of failed tiles returned to the caller.

#### Backend / runner errors

Backend trait requirements:

- All backend methods return `raster_core::Result<...>`.
- Backends MUST return an error (not a panic) for unsupported operations.

Native backend (`raster-backend/src/native.rs`):

- Proof generation or verification requested in native mode returns:
  - `Error::Other("Native backend does not support ... Use the RISC0 backend.")`
- Tile execution is currently a placeholder and does not execute the registry-backed tile (returns empty output).

**GAP:** Native execution via registry is explicitly TODO; “execution failures” here are not representative of the intended design.

RISC0 backend (`raster-backend-risc0/src/risc0.rs`):

- Compilation failures (guest build, tempdir, IO, image id computation) are typically returned as:
  - `Error::Other("...")` with a formatted message.
- Execution failures (executor/prover errors) are returned as:
  - `Error::Other("Execution failed: ...")`
  - `Error::Other("Proving failed: ...")` / `Error::Other("GPU proving failed: ...")`
- Verification in `ExecutionMode::Prove { verify: true }` sets `TileExecution.verified`:
  - If verification throws an error, it currently yields `verified = false` rather than returning an error.

Requirements:

- If `verify = true`, implementations MUST surface verification status deterministically.
  - Returning `Ok(verified=false)` is permitted (and is how Raster currently behaves).
  - Implementations SHOULD distinguish “invalid proof” from “verification errored” (host failure).

**GAP:** Raster currently collapses “verification errored” into `verified=false` in the prove path, losing diagnostic detail.

RISC0 guest builder (`GuestBuildError`):

- Guest crate build may fail due to missing toolchain, subprocess failure, or missing ELF.
- These are structured in `GuestBuildError`, but the RISC0 backend currently string-wraps them into `raster_core::Error::Other`.

### Diagnostics

Raster tools that present errors to a user (notably the CLI) MUST include:

- The **phase** of failure (discover, compile, execute, prove, verify, serialize/deserialize).
- The **subject** (tile id / sequence id) when applicable.
- The **actionable hint** when the error is due to common misconfiguration (missing toolchain, wrong backend, GPU unavailable).

Current behavior notes:

- The CLI uses `anyhow` and prints user-facing status lines; some errors get additional context (`.context("...")`), but many are raw strings.
- GPU “requested but unavailable” is currently a warning with remediation text.

**GAP:** There is no stable, structured “diagnostic object” (e.g., JSON with fields `code`, `phase`, `subject`, `message`, `source`). All diagnostics are effectively text.

### Verifiable vs host failures (mapping table)

Implementations MUST treat the following as:

- **Verifiable failures**:
  - Guest aborts/panics during tile execution.
  - Receipt verification returns invalid (proof does not verify against method/image id).
- **Host failures**:
  - Missing `rzup`/RISC0 toolchain, cargo subprocess failure, tempdir creation, file IO.
  - Failure to deserialize receipt bytes.
  - Failure to serialize receipt bytes.

**Current implementation caveat:** Many of these propagate via `Error::Other(String)` without a machine-readable classification.

### Examples (reflecting current behavior)

#### Example: tile wrapper input deserialization failure

If a tile is called with bytes that are not valid `postcard` for the tile’s expected input type, the generated tile entrypoint MUST return:

- `Err(Error::Serialization("Failed to deserialize input: ..."))`

#### Example: requesting proofs on native backend

If a caller requests proving in native backend mode, the backend MUST return an error equivalent to:

- `Err(Error::Other("Native backend does not support proof generation. Use the RISC0 backend."))`

#### Example: RISC0 toolchain missing during compilation

If the RISC0 toolchain cargo cannot be located, compilation MUST fail as a host failure; currently it surfaces as:

- `Err(Error::Other("Failed to build guest for tile '...': Compilation failed: RISC0 toolchain not found. Please install it with: rzup install"))`

### Known gaps and divergences (tracked TODOs)

- **Stable error codes**: Raster SHOULD define stable, documented error codes for user-facing failures (e.g., `E_TILE_NOT_FOUND`, `E_TOOLCHAIN_MISSING`, `E_RECEIPT_INVALID`). **GAP: not implemented.**
- **Structured diagnostics**: Raster SHOULD provide a structured diagnostic payload with `phase`, `subject`, and source chaining. **GAP: not implemented.**
- **Macro panics**: Macros SHOULD emit span-aware compile errors instead of panicking. **GAP: current code panics for invalid `#[tile(...)]` usage.**
- **CLI IO swallowing**: The CLI SHOULD not silently replace IO/hex decode failures with empty data. **GAP: current `commands.rs` uses `unwrap_or_default()` for reading ELF and decoding method id in some paths.**
