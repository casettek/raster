## Divergence Detection

This document specifies how a challenger identifies the **first point of divergence** between:

- a **claimed execution** (represented by a claimed trace commitment / fingerprint), and
- a **recomputed execution** (produced by re-executing the program from the same inputs and artifacts),

and how the challenger selects a **window replay** interval to construct a minimal dispute.

Raster’s current codebase contains only a minimal, event-oriented `Trace` model and does **not** implement:

- trace commitments or fingerprints,
- commitment-based comparison between a claimed trace and a recomputed trace,
- locating the first divergence, or
- window replay selection/execution.

Where this document specifies those behaviors, it explicitly marks them as a **GAP** so implementers do not assume capabilities that are not present today.

---

### Code audit tasks (where to look)

#### What exists today (trace data model + capture stubs)

- **Trace type and event enum**
  - `crates/raster-core/src/trace.rs` (`Trace`, `TraceEvent`)
  - Note: events are *structural/perf* oriented (start/end, timestamps, cycles), not “I/O transcript” oriented.
- **Trace capture pipeline (in-memory only; no persistence)**
  - `crates/raster-runtime/src/tracer.rs` (`Tracer`, `FileTracer`, `NoOpTracer`)
    - `FileTracer::finalize` returns an in-memory `Trace` and does not write to disk (`TODO`).
  - `crates/raster-runtime/src/executor.rs`
    - `Executor::execute` is stubbed (`TODO`) and does not currently produce trace events.
- **Downstream analysis plumbing (stubbed)**
  - `crates/raster-analysis/src/analyzer.rs` (accepts `Trace`, analysis is `TODO`)
  - `crates/raster-cli/src/commands.rs` (`analyze` currently prints “not yet implemented”)

#### Inputs that a real verifier/challenger would need (partially implemented elsewhere)

- **Artifact identity (zkVM image/method ID)**
  - RISC0 image id: `crates/raster-backend-risc0/src/risc0.rs` (`risc0_zkvm::compute_image_id(&elf)`)
  - How it’s stored in build artifacts: `crates/raster-backend-risc0/src/guest_builder.rs` (`manifest.json`, `method_id`)
  - Native backend “method id” placeholder: `crates/raster-backend/src/native.rs` (**not cryptographic**)
- **Host↔guest ABI for tile execution (needed to replay faithfully)**
  - Host input writes: `crates/raster-backend-risc0/src/risc0.rs` (`Risc0Backend::execute_tile`)
  - Guest main generator: `crates/raster-backend-risc0/src/guest_builder.rs` (`generate_guest_main`)
- **Hashing conventions**
  - `specs/Core/0. Conventions/01. IDs and Hashing.md`
  - Important: this spec already documents that **trace commitments are not implemented** today.

#### What is missing (confirm by inspection/search)

- **Trace commitment / fingerprint algorithms**: no `TraceFingerprint` type, no per-step hash, no trace “root”.
- **Trace comparison / divergence locator**: no code that compares a recomputed trace to a claimed commitment.
- **Window replay runner**: no code that replays a slice of execution against a stored trace.

---

### Definitions

- **Claimed trace**: an asserted representation of an execution suitable for verification (intended to be a commitment or fingerprint).
- **Recomputed trace**: the challenger’s execution record produced by re-running from the same declared inputs and artifacts.
- **Divergence**: the earliest index at which the claimed and recomputed executions disagree under the comparison rules in this document.
- **Replay window**: a contiguous interval of execution steps selected for replay to construct minimal evidence of divergence.

**Important implementation note (current code):** `raster_core::trace::Trace` is an ordered list of coarse-grained events and does not define an execution “step” with input/output bytes. This limits what can be compared today.

---

### 1. Current implementation status (what can and cannot be done today)

#### 1.1 What is implemented today

- A `Trace { run_id, timestamp, events: Vec<TraceEvent> }` data model exists (`crates/raster-core/src/trace.rs`).
- A `Tracer` trait exists, with:
  - `NoOpTracer` returning `None`, and
  - `FileTracer` buffering events and returning an in-memory `Trace` in `finalize()` (`crates/raster-runtime/src/tracer.rs`).

#### 1.2 What is not implemented today (GAP)

The Raster implementation does not currently provide:

- any trace persistence format or canonical on-disk encoding,
- any trace commitment or fingerprint computation,
- any mechanism for a challenger to compare a recomputed trace against a claimed commitment,
- any “first divergence” locator,
- any window replay execution.

As a result, the remainder of this document specifies the **required behavior for a future implementation**, and implementers MUST treat it as a contract to be implemented rather than a description of current behavior.

---

### 2. Comparison objects and ordering (GAP / not implemented)

To support divergence detection, the system MUST define a canonical, ordered stream of **step records**.

#### 2.1 Step record (required fields)

A step record MUST include, at minimum:

- **Step index** (0-based, monotonically increasing in execution order)
- **Callee identity**
  - `TileId` (or SequenceId if sequences are executed as steps)
- **Artifact identity**
  - backend-specific method/image id (e.g., RISC0 image id)
- **Input bytes** \(B_{in}\) (canonical encoding)
- **Output bytes** \(B_{out}\) (canonical encoding), or an explicitly defined error output

**GAP (current code):** `TraceEvent` does not include artifact identity nor \(B_{in}\)/\(B_{out}\), so this step record cannot be reconstructed from `Trace` today.

#### 2.2 Canonical order

The step record stream MUST be ordered exactly as execution occurs.

- Implementations MUST assign step indices deterministically from that order.
- Implementations MUST ensure that recursive execution expands into multiple step records (one per iteration), in order.

**GAP (current code):** the runtime executor does not implement sequence execution or recursion, so there is no authoritative step ordering in code yet.

---

### 3. Divergence detection protocol (GAP / not implemented)

This section specifies how a challenger compares a recomputed execution against a claimed execution.

#### 3.1 Inputs

A challenger MUST be able to obtain:

- **Claimed identity**:
  - a trace commitment (preferred) or trace fingerprint (index key) of the claimed execution
- **Program material**:
  - the CFS / schema describing allowed execution order and dataflow
- **Artifacts**:
  - compiled tile artifacts and their artifact identities (e.g., RISC0 image ids)
- **External inputs**:
  - the entrypoint inputs for `main` (in canonical encoding)

**GAP (current code):** there is no implemented schema-driven executor and no implemented trace commitment, so this input set cannot be consumed end-to-end today.

#### 3.2 Output

The divergence detector MUST output either:

- `NoDivergence` (claimed and recomputed executions match), or
- `Divergence { step_index, reason, replay_window }`

where `replay_window` is selected as described in §4.

#### 3.3 Procedure: locate the first divergence

Given a claimed execution representation and a recomputed execution representation, implementations MUST locate the earliest mismatch under the following precedence:

1. **Length mismatch**
   - If one execution ends earlier than the other, divergence is the first index past the shorter stream (the “missing step”).
2. **Step identity mismatch**
   - If step indices align but `TileId` (or callee) differs, divergence is that step.
3. **Artifact identity mismatch**
   - If `TileId` matches but artifact identity differs, divergence is that step.
4. **Input mismatch**
   - If artifact matches but \(B_{in}\) differs, divergence is that step.
5. **Output mismatch**
   - If inputs match but \(B_{out}\) differs (or one errors and the other does not), divergence is that step.

##### Efficient localization (recommended)

If the claimed side provides commitment structure that supports subrange proofs (e.g., per-window commitments or a Merkle tree over step records), the challenger SHOULD use a logarithmic search:

- compare commitments at progressively smaller ranges (binary search) to isolate the first mismatching step index,
- then request or compute the minimal replay window that contains that step.

**GAP (current code):** no such commitment structure exists in Raster today.

##### Fallback localization (linear)

If the challenger has direct access to both full step-record streams (claimed + recomputed), the challenger MAY locate divergence by linear scan from index 0.

**GAP (current code):** Raster does not provide a full step-record stream in `Trace`; only coarse `TraceEvent`s exist.

---

### 4. Replay window selection (GAP / not implemented)

This section specifies how to select the replay window once a divergence index is known.

#### 4.1 Window parameterization

Window replay requires a window size parameter:

- `window_size_steps` MUST be a positive integer.
- A window MUST be defined as a contiguous range of step indices \([start, end)\) with:
  - `end - start <= window_size_steps`

**GAP (current code):** there is no `window_size_steps` parameter in the CLI/runtime/verify code today.

#### 4.2 Selecting the divergence window

Given a divergence step index `d`, the selected replay window MUST:

- include `d`, and
- include sufficient context to reconstruct the initial input to step `start`.

Because step inputs are derived from prior committed outputs under the CFS, the replay window MUST satisfy one of:

- **Option A (explicit initial input)**: the replay request includes the exact \(B_{in}\) for step `start`, or
- **Option B (context-carrying prefix)**: the window begins at step 0, or includes a prefix sufficient to derive \(B_{in}\) for `start` from within-window commitments.

Recommended rule (with explicit initial input available):

- Let `w = window_size_steps`.
- Let `start = floor(d / w) * w`.
- Let `end = min(start + w, total_steps)`.
- Select replay window \([start, end)\).

#### 4.3 Boundary hardening (recommended)

To reduce ambiguity around boundary conditions (e.g., if the divergence is caused by a mismatch in the input to step `start`), implementations SHOULD allow widening the replay request to include the previous window as context:

- If `start > 0`, the challenger MAY select \([start - w, end)\) or request both windows \([start - w, start)\) and \([start, end)\).

**GAP (current code):** there is no implemented runner that can replay windows, so there is no concrete boundary-handling behavior yet.

---

### 5. Error cases and required diagnostics (GAP / not implemented)

If divergence detection cannot proceed, implementations MUST return a diagnostic error that includes a phase and actionable context.

At minimum, divergence detection MUST error on:

- missing claimed commitment/fingerprint for the targeted run,
- missing artifacts required to recompute the run,
- inability to map claimed data to an ordered step stream,
- malformed claimed commitment proofs (if provided),
- out-of-bounds window selectors.

---

### 6. Examples

#### 6.1 Example: locating divergence by linear scan (conceptual)

Assume two step streams (shown as tuples `(tile_id, method_id, in_hash, out_hash)` for brevity):

- Claimed:
  - step 0: `(A, mA, h0, h1)`
  - step 1: `(B, mB, h1, h2)`
  - step 2: `(C, mC, h2, h3)`
- Recomputed:
  - step 0: `(A, mA, h0, h1)`
  - step 1: `(B, mB, h1, hX)`  ← mismatch
  - step 2: `(C, mC, hX, hY)`

The first divergence is `step_index = 1` due to **output mismatch** at step 1.

**GAP:** Raster does not expose these step tuples today.

#### 6.2 Example: selecting a window from divergence index

Given:

- `window_size_steps = 64`
- divergence index `d = 70`

Then:

- `start = floor(70 / 64) * 64 = 64`
- `end = 128` (or `min(128, total_steps)`)

Select replay window \([64, 128)\), which contains step 70.

**GAP:** Raster does not currently implement window replay execution.

