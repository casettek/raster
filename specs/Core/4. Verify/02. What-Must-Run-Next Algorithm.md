## What-Must-Run-Next Algorithm

This document specifies how a verifier (or any “audit” runner) derives the **unique next required execution action** from a Control Flow Schema (CFS) and previously committed results.

It is written to match the current codebase. Where the intended behavior is not yet implementable from existing data structures, this document calls that out explicitly and describes the required behavior.

---

## Code audit tasks (where to look)

- **CFS data model (what information exists today)**
  - `crates/raster-core/src/cfs.rs`
    - `ControlFlowSchema`
    - `TileDef` (`id`, `type`, `inputs`, `outputs`)
    - `SequenceDef` (`id`, `input_sources`, `items`)
    - `SequenceItem` (`item_type`, `item_id`, `input_sources`)
    - `InputBinding`, `InputSource::{External, SeqInput, ItemOutput}`
- **How CFS is produced (binding resolution rules that determine what a verifier will see)**
  - `crates/raster-compiler/src/cfs_builder.rs`
    - `CfsBuilder::build` (emits `encoding = "postcard"`)
    - `build_sequence_def(...)` (sets all `SequenceDef.input_sources` to `external`)
  - `crates/raster-compiler/src/discovery.rs`
    - `SequenceCall { arguments, result_binding, is_recursive }`
    - `parse_call_expr(...)` recognizes `callee!(...)` by stripping `!` and setting `is_recursive = true`
  - `crates/raster-compiler/src/flow_resolver.rs`
    - `resolve_argument(...)` mapping:
      - exact param name → `SeqInput { input_index }`
      - exact bound name → `ItemOutput { item_index, output_index }` (currently always `0`)
      - otherwise → `External` fallback
    - Note: `is_recursive` is currently ignored; it does not affect emitted `SequenceItem`s.
- **Recursive-tile authoring signal**
  - `crates/raster-macros/src/lib.rs`
    - `#[tile(recur)]` emits a `macro_rules! tile_name { ... }` so authors can write `tile_name!(...)`
    - Docstring states the `!` syntax “signals to the CFS compiler” recursive execution intent
- **Trace data model currently available**
  - `crates/raster-core/src/trace.rs`
    - `TraceEvent::{TileStart, TileEnd, SequenceStart, SequenceEnd}` (no committed input/output bytes today)
- **Runtime/verification implementation status**
  - `crates/raster-runtime/src/executor.rs` is stubbed (`TODO: Implement execution`)
  - No verifier-side API exists today that consumes a CFS + committed step outputs and enforces “next step” determinism.

---

## Spec output

### 1) Inputs and outputs of the algorithm

The algorithm consumes:

- A CFS `ControlFlowSchema` as defined in `raster_core::cfs`.
- A chosen **entry sequence id** (see §2.1).
- A committed set of **external inputs** for the entry invocation.
- A committed prefix of **prior execution results** (see §1.2) sufficient to decide “what must run next”.

The algorithm outputs exactly one of:

- **Next tile execution required**, specifying:
  - tile id,
  - required input bytes for the next execution,
  - and the “position” within the program being executed (sequence stack + item index + optional recursion iteration).
- **Execution complete** (normal termination for the entry invocation).
- **Invalid trace / invalid schema** (with an error reason).

#### 1.1 Determinism requirement

Given the same CFS, the same external inputs, and the same committed prior results, the algorithm MUST produce the same output.

#### 1.2 Required prior-result record (gap vs current code)

To derive next-step inputs mechanically, a verifier needs committed per-step I/O bytes.

**Current gap:** `raster_core::trace::Trace` does not contain tile input/output bytes, and no other “step record” type exists in `raster-core` today. As a result, the algorithm below is not implementable purely from `raster_core::trace` as currently defined.

Minimum required record per tile execution (including each recursion iteration) is:

- `tile_id`
- `input_bytes`
- `output_bytes`

A verifier MUST reject any trace format that does not commit to enough material to reproduce these values deterministically.

---

### 2) Preconditions and validation checks

#### 2.1 Entry sequence selection

For the purposes of verification, the entrypoint MUST be the sequence with id `"main"` if present.

- If `"main"` does not exist, verifiers MUST reject verification attempts as “no entry sequence”.

**Current gap:** the emitted CFS does not contain an explicit “entrypoint” field; consumers must select it by convention.

#### 2.2 CFS well-formedness checks

A verifier MUST validate the following before attempting next-step derivation:

- **Tile IDs are unique**
  - No two `TileDef` entries may share the same `id`.
- **Sequence IDs are unique**
  - No two `SequenceDef` entries may share the same `id`.
- **All referenced callees exist**
  - For each `SequenceItem`:
    - If `item_type == "tile"`, `item_id` MUST match a `TileDef.id`.
    - If `item_type == "sequence"`, `item_id` MUST match a `SequenceDef.id`.
  - If `item_type` is neither `"tile"` nor `"sequence"`, the CFS MUST be rejected.
  - If `item_type` disagrees with what exists (e.g. says `"tile"` but only a sequence exists), the CFS SHOULD be rejected.
    - **Current producer behavior:** `item_type` is best-effort and may fall back to `"tile"` when unknown; a verifier should treat that as untrusted and validate it.
- **Argument arity matches**
  - If `item_type == "tile"`, the number of `SequenceItem.input_sources` MUST equal the referenced `TileDef.inputs`.
  - If `item_type == "sequence"`, the number of `SequenceItem.input_sources` MUST equal the referenced `SequenceDef.input_sources.len()` (its parameter count).
    - **Current gap:** `SequenceDef.input_sources` is always `external` today, but the length is still meaningful as the parameter count.
- **Index safety for bindings**
  - For `InputSource::SeqInput { input_index }`, `input_index` MUST be within the current sequence invocation’s input vector.
  - For `InputSource::ItemOutput { item_index, output_index }`:
    - `item_index` MUST be `< current_item_index` (no forward references).
    - `output_index` MUST be `< outputs_of(item_index)`.
      - For `item_type=="tile"`, `outputs_of(i) = TileDef.outputs`.
      - For `item_type=="sequence"`, see §2.4 (gap).

#### 2.3 External inputs restrictions

In a fraud-provable setting, any `InputSource::External` appearing inside a sequence item MUST be treated as a hard failure unless it can be satisfied by the invocation’s explicitly committed external inputs.

Minimum rule set:

- For the entry invocation of `"main"`, `External` MAY be used only to reference explicitly committed entry inputs.
- For non-entry sequences, `External` SHOULD NOT appear in item arguments; all arguments SHOULD be derivable from `SeqInput` or `ItemOutput`.

**Current producer behavior:** unresolved arguments (literals, expressions) are encoded as `External` by the compiler’s flow resolver. Verifiers MUST treat such CFS instances as not mechanically verifiable unless an out-of-band rule is provided to supply those values.

#### 2.4 Nested sequence outputs (gap)

To support `InputSource::ItemOutput` that references a prior item whose `item_type == "sequence"`, a verifier needs:

- the output arity of the nested sequence invocation, and
- a defined rule for how those outputs are produced.

**Current gap:** `raster_core::cfs` does not model sequence output arity, and the compiler currently assumes a single output (`output_index = 0`) when binding `let x = callee(...)` regardless of callee kind.

Until a sequence-output model exists, verifiers MUST reject any CFS/trace pair that requires selecting outputs from a nested sequence invocation via `ItemOutput`.

---

### 3) Execution model used for “next step” derivation

This spec interprets the emitted CFS as a linear, ordered execution plan:

- Each `SequenceDef.items` is an ordered list.
- The next required action is determined by executing items in order, expanding nested sequences by entering them, and expanding recursive tiles by iterating them until termination.

**Current gap:** the codebase does not include a runtime/verifier that executes CFS directly today; this is the intended model that downstream verifiers MUST implement.

#### 3.1 State tracked by the verifier

To derive what must run next, a verifier maintains an abstract execution state:

- A **call stack** of sequence frames.
  - Each frame has:
    - `sequence_id`
    - `inputs` (the invocation’s input value vector, as canonical-encoded bytes per input)
    - `next_item_index` (0-based index into `SequenceDef.items`)
- Optionally, an active **recursive tile iteration**, containing:
  - `tile_id`
  - `iteration_index`
  - `current_iteration_input_bytes`

The verifier also has access to the committed prior results to validate that any already-executed step matched what the verifier would have required at that point.

---

### 4) Deriving required inputs for a call

Given a sequence frame with inputs `seq_inputs[]` (each element is a canonical-encoded value), and having access to prior item outputs `item_outputs[item_index][output_index]` (canonical-encoded values), the required input for a callee argument is derived as:

- If `source == SeqInput { input_index }`:
  - required value is `seq_inputs[input_index]`.
- If `source == ItemOutput { item_index, output_index }`:
  - required value is `item_outputs[item_index][output_index]`.
- If `source == External`:
  - required value MUST come from a committed external input channel associated with the current sequence invocation.
  - If no such committed value exists, verification MUST fail.

#### 4.1 Tile ABI input bytes

Once the verifier has the callee’s logical input values, it MUST construct the tile ABI `input_bytes` as follows, matching the tile macro’s wrapper behavior (Postcard):

- If the tile has 0 inputs, `input_bytes` MUST be the canonical encoding of `()`.
- If the tile has 1 input, `input_bytes` MUST be the canonical encoding of that single value.
- If the tile has \(k>1\) inputs, `input_bytes` MUST be the canonical encoding of the \(k\)-tuple in argument order.

**Current gap:** the CFS does not carry types. Constructing bytes from “logical values” therefore requires additional ABI/type information not present in `raster_core::cfs` today.

---

### 5) The next-step derivation algorithm

This section defines the deterministic “what must run next” procedure.

#### 5.1 High-level procedure

Given the current execution state:

1. If an active recursive tile iteration exists, the next required action is the next iteration of that tile (see §6).
2. Otherwise, look at the top sequence frame:
   - If `next_item_index == items.len()`, the sequence invocation is complete; pop the frame and treat its “result” as available to its caller (see §2.4 for current limitations).
   - Else, inspect `items[next_item_index]`:
     - If it is a tile item: derive required input bytes and require that tile execution next.
     - If it is a sequence item: derive the nested sequence invocation’s inputs and push a new frame for that sequence with `next_item_index = 0`.

The entry invocation completes when the call stack becomes empty.

#### 5.2 Uniqueness requirement

At any point in a valid execution prefix, there MUST be exactly one next required tile execution determined by this algorithm.

If multiple actions are possible (e.g. because a control-flow branch is under-specified), the CFS is insufficient for verification and MUST be rejected.

**Current producer limitation:** the emitted CFS represents only linear sequences and does not encode conditionals/loops within sequences. Therefore, uniqueness is expected for the subset of programs the compiler can currently represent.

---

### 6) Recursive tile iteration transitions

Recursive tile execution is signaled in the current system by the tile definition’s kind string:

- A tile with `TileDef.type == "recur"` MUST be treated as a recursive tile by verifiers.

**Current gap:** call-site `callee!(...)` intent is discovered but dropped in the CFS; verifiers cannot distinguish `callee(...)` vs `callee!(...)` from the CFS alone. Therefore, treating recursion as a tile-level property is the only mechanically available rule today.

#### 6.1 Recursive tile contract checks

Before verifying recursion, a verifier MUST enforce:

- The recursive tile’s output arity MUST be exactly `inputs + 1`.
- The first output value MUST be a boolean `done`.

**Current gap:** the `#[tile(recur)]` macro does not enforce either constraint at compile time.

#### 6.2 Iteration step rule

Let the recursive tile have input vector \(S_i\) (the “state”) and output vector \((done_i, S_{i+1})\).

Rules:

- Iteration 0 input \(S_0\) is derived from the sequence item’s input bindings (as in §4).
- For iteration \(i \ge 0\):
  - The required tile execution input bytes for iteration \(i\) MUST be the tile ABI encoding of \(S_i\) (as in §4.1).
  - The committed output bytes for iteration \(i\) MUST decode to a tuple whose first element is `done_i` and remaining elements are \(S_{i+1}\).
  - If `done_i == false`, the next required action MUST be iteration \(i+1\) with input derived from \(S_{i+1}\).
  - If `done_i == true`, the recursive invocation completes and control returns to the containing sequence item.

#### 6.3 Termination and bounds

- A recursive invocation MUST eventually terminate with `done == true`.
- Runners/verifiers MAY impose a maximum iteration bound, but if the bound is exceeded the run MUST be rejected as invalid (it MUST NOT be treated as successful termination).

**Current gap:** there is no runtime implementation that performs recursion driving or enforces bounds today.

---

### 7) Examples

#### 7.1 Linear next-step derivation (tile → tile)

Given this CFS excerpt:

```json
{
  "version": "1.0",
  "project": "hello-tiles",
  "encoding": "postcard",
  "tiles": [
    { "id": "greet", "type": "iter", "inputs": 1, "outputs": 1 },
    { "id": "exclaim", "type": "iter", "inputs": 1, "outputs": 1 }
  ],
  "sequences": [
    {
      "id": "main",
      "input_sources": [ { "source": { "type": "external" } } ],
      "items": [
        {
          "item_type": "tile",
          "item_id": "greet",
          "input_sources": [ { "source": { "type": "seq_input", "input_index": 0 } } ]
        },
        {
          "item_type": "tile",
          "item_id": "exclaim",
          "input_sources": [ { "source": { "type": "item_output", "item_index": 0, "output_index": 0 } } ]
        }
      ]
    }
  ]
}
```

Let the committed external input for `main` be a single value `name` (canonically encoded).

Derivation:

- At start, `next_item_index = 0`, so the next required action is tile `greet` with input derived from `SeqInput[0]`.
- After `greet` executes, the next required action is tile `exclaim` with its sole argument derived from `ItemOutput(0,0)`, i.e. the output of `greet`.

#### 7.2 External fallback in arguments (not mechanically verifiable)

For a sequence containing:

```rust
let y = add_one(x + 1);
```

the compiler will treat `"x + 1"` as an unresolved argument string and encode it as `InputSource::External`.

A verifier MUST reject attempts to mechanically derive the next step unless an explicit, committed external value is provided for that argument (and the rules allowing it are defined).

#### 7.3 Recursive tile iteration (conceptual)

Suppose a tile `step` is declared with `type = "recur"`, `inputs = 1`, `outputs = 2`, and returns `(done: bool, next_state: S)`.

Then:

- Iteration 0 input is derived from the sequence bindings.
- Each subsequent iteration’s input MUST equal the prior iteration’s `next_state` encoded per the tile ABI.
- The recursive call terminates on the first iteration whose decoded `done` is `true`.

