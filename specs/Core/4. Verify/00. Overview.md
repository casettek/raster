## Purpose and scope

This section defines the **Verify** stage of Raster Core: what it means to “verify” an execution claim, what artifacts are required, what outputs a verifier produces, and how verification relates to dispute/fraud-proof workflows.

This document is written to match the codebase as it exists today and explicitly marks gaps where the intended “program verification” architecture is not yet implemented.

---

## Code audit tasks (where to look)

### Verifier entrypoints (offchain) (implemented for single-tile zk receipts)

- **Backend verification API surface**
  - Inspect `crates/raster-backend/src/backend.rs`
    - `trait Backend::verify_receipt(compilation, receipt) -> Result<bool>`
    - `struct CompilationOutput { elf, method_id, artifact_dir }`
    - `enum ExecutionMode::{Estimate, Prove{verify}}`
    - `struct TileExecution { receipt, verified, output, cycles, ... }`
- **RISC0 receipt verification implementation**
  - Inspect `crates/raster-backend-risc0/src/risc0.rs`
    - Receipt encoding: `bincode::serialize` / `bincode::deserialize`
    - Verification target: `image_id = risc0_zkvm::compute_image_id(&compilation.elf)`
    - Verification: `receipt.verify(image_id)`
    - Note: verification recomputes the image id from `compilation.elf`; it does not use `compilation.method_id` as the source of truth.
- **CLI “verify” entrypoint**
  - Inspect `crates/raster-cli/src/main.rs` and `crates/raster-cli/src/commands.rs`
    - `cargo raster run --backend risc0 --prove --verify` requests `ExecutionMode::prove_and_verify()`.
    - CLI prints only a boolean “Verified: true|false”; it does not persist receipts or traces.

### Trace/schema verification plumbing (not implemented end-to-end)

- **Trace type (what “trace” means today)**
  - Inspect `crates/raster-core/src/trace.rs`
    - `Trace { run_id, timestamp, events: Vec<TraceEvent> }`
    - `TraceEvent::{TileStart, TileEnd, SequenceStart, SequenceEnd}`
    - Note: this is an event/performance trace; it does not include per-step input/output bytes.
- **Runtime executor + tracer stubs**
  - Inspect `crates/raster-runtime/src/executor.rs`
    - `Executor::execute(schema: &SequenceSchema)` is a TODO and does not execute anything yet.
  - Inspect `crates/raster-runtime/src/tracer.rs`
    - `FileTracer::finalize` does not write to disk (TODO) and sets `timestamp = 0`.
- **Schemas / CFS (inputs a future verifier would consume)**
  - Inspect `crates/raster-core/src/cfs.rs` and `crates/raster-compiler/src/cfs_builder.rs`
    - CFS JSON exists and can be generated by the CLI `cfs` command, but no verifier consumes it today.

### On-chain interface assumptions (not implemented in codebase)

- There is no on-chain client, contract ABI, or calldata format in Raster Core.
- For the current “proof-like” artifacts that exist, inspect:
  - `crates/raster-backend-risc0/src/risc0.rs` (receipt bytes and verification)
  - `crates/raster-backend-risc0/src/guest_builder.rs` (what the guest commits to the journal)
  - Spec companion: `specs/Core/4. Verify/05. On-chain Interface Assumptions.md`

---

## Verification: definitions and goals

### 1) What “verification” means in Raster Core

In Raster Core, “verification” has two distinct meanings:

1. **Local proof verification (implemented for single tiles, zkVM backend only)**:
   - Given a tile artifact (guest program) and a zk receipt, check that the receipt is valid for that program, and read the receipt’s public output (journal bytes).
2. **Program/trace verification and dispute support (not implemented today)**:
   - Given a program description (CFS/schema), external inputs, and a claimed execution transcript/commitment, check that:
     - the next required step is uniquely determined,
     - each executed step’s inputs are derivable from prior committed outputs,
     - and any divergence from recomputation can be located and turned into minimal evidence (fraud proof).

Today, only (1) exists as code. The rest of Verify is specified across the other files in this folder, but must be treated as a contract to be implemented.

### 2) “Local trace checks” vs “fraud proof generation”

- **Local trace checks** are checks a node performs for its own confidence while executing or replaying:
  - receipt validity (when a receipt exists),
  - basic structural sanity (well-formed artifacts, well-formed receipt encoding),
  - and, in a future implementation, “this trace is consistent with the CFS and deterministic next-step rules.”

- **Fraud proof generation** is producing externally checkable evidence that a claim is false:
  - it requires a precise divergence point and a minimal replay window,
  - and it requires commitment formats and replay semantics that a third party (or an on-chain verifier) can validate.

In the current codebase, fraud proof generation is not implemented, and even “local trace checks” beyond receipt verification are not implemented because there is no persisted, I/O-bearing step transcript.

---

## What is verifiable today (as implemented)

### 1) Tile-level receipt verification statement (RISC0 backend)

For the RISC0 backend, receipt verification establishes:

- The verifier **MUST** compute the image id from the exact guest ELF bytes:
  - `image_id = risc0_zkvm::compute_image_id(guest_elf_bytes)`
- The verifier **MUST** verify the receipt against that image id:
  - `receipt.verify(image_id)`
- If verification succeeds, the verifier **MAY** treat the receipt journal bytes as the tile’s public output:
  - `output_bytes = receipt.journal.bytes`

Important limitations of the current implementation:

- The receipt encoding **MUST** be treated as Rust `bincode` of `risc0_zkvm::Receipt` (this is how Raster currently serializes/deserializes receipts).
- The receipt does **not** (by itself) bind the host-provided input bytes unless the guest commits them (or a digest) into the journal.
  - In Raster’s current generated guest, the guest commits only the output bytes to the journal.

### 2) Required inputs and outputs for the implemented verifier

**Inputs (effective, in-memory):**

- `guest_elf_bytes: [u8]`
- `receipt_bytes: [u8]` (bincode-serialized `risc0_zkvm::Receipt`)

**Output:**

- `valid: bool` (`Backend::verify_receipt` returns `Result<bool>`)
  - `Ok(true)` means the receipt verified successfully.
  - `Ok(false)` means the receipt failed verification.
  - `Err(...)` means decoding failed or the image id could not be computed.

---

## What verification is intended to cover (spec-only today; not implemented)

This folder’s other documents describe the intended program-level verification workflow:

- **Verifier I/O**: see `specs/Core/4. Verify/01. Verifier Inputs and Outputs.md`
- **Deterministic next-step rule**: see `specs/Core/4. Verify/02. What-Must-Run-Next Algorithm.md`
- **Divergence and window replay selection**: see `specs/Core/4. Verify/03. Divergence Detection.md`
- **Fraud proof construction**: see `specs/Core/4. Verify/04. Fraud Proof Construction.md`
- **On-chain assumptions**: see `specs/Core/4. Verify/05. On-chain Interface Assumptions.md`

The current Raster codebase does not yet provide:

- a verifier API that consumes CFS/schema + committed step records,
- a step-record format that commits to per-step input/output bytes,
- trace persistence and trace commitments/fingerprints,
- a divergence locator, window replay runner, or fraud proof object format.

Any implementation building on Raster today **MUST** treat these as missing and build them as additional components (or constrain itself to tile-level receipt verification only).

---

## Examples

### Example: local receipt verification during CLI run (RISC0)

```bash
cargo raster run --backend risc0 --tile <tile_id> --prove --verify
```

Expected behavior (current):

- The backend generates a RISC0 receipt for the tile execution.
- The backend performs local receipt verification and returns `verified = Some(true|false)`.
- The CLI prints `Verified: true|false`.

### Example: “program verification” is not available yet

Raster does not currently offer a command or library entrypoint that can:

- load a CFS for `main`,
- replay a multi-tile execution,
- validate a claimed trace against deterministic next-step rules,
- and produce a divergence point or fraud proof.

Those capabilities are described in the Verify specs but are not implemented in `crates/raster-core` / `crates/raster-runtime` today.
