## Trace Commitment and Fingerprinting

This document specifies how Raster execution traces are *intended* to be committed (cryptographic commitment) and how shorter *fingerprints* are derived for indexing and replay workflows.

It also documents the current implementation status and explicitly identifies gaps between this spec and the codebase as it exists today.

---

### Code audit tasks (where to look)

- **Trace data model (fields, event variants, serde shape)**
  - `crates/raster-core/src/trace.rs` (`Trace`, `TraceEvent`)
- **Trace capture pipeline (where events come from, persistence)**
  - `crates/raster-runtime/src/tracer.rs` (`Tracer`, `FileTracer`, `NoOpTracer`)
  - `crates/raster-runtime/src/executor.rs` (where tracing would be invoked; currently stubbed)
- **Downstream consumption**
  - `crates/raster-analysis/src/analyzer.rs` (accepts `Trace`, currently stubbed)
- **Existing hashing/ID conventions used elsewhere (for alignment)**
  - `specs/Core/0. Conventions/01. IDs and Hashing.md`
- **“Window size” parameter usage**
  - **GAP**: there is no `window_size` parameter in CLI/runtime/verify code today; confirm by searching for `window_size` / `window` across `crates/`.

---

### 1. Current implementation status (what exists today)

Raster currently provides:

- A `Trace` struct and `TraceEvent` enum that can be serialized/deserialized via `serde` (std-only module).
- A `Tracer` trait and two implementations:
  - `NoOpTracer` (does nothing)
  - `FileTracer` that buffers events in memory and returns a `Trace` in `finalize()`

However:

- There is **no trace persistence format** (the file tracer has a `TODO: Write trace to file`).
- The returned `Trace.timestamp` is currently hard-coded to `0` (there is a `TODO` to populate it).
- There is **no commitment hash**, **no per-step hashing**, **no fingerprint projection**, and **no windowing logic** implemented anywhere in the codebase.
- There is **no cryptographic hash dependency** (e.g., `sha2`, `blake3`) in the current workspace manifests.

As a result:

- Any “trace commitment” or “trace fingerprint” discussed below is **not produced by current Raster code** and therefore cannot be validated against the current implementation.

---

### 2. Trace object model (implemented)

#### 2.1 Trace

A `Trace` is an in-memory record of events:

- `run_id: String`
- `timestamp: u64`
- `events: Vec<TraceEvent>`

**Ordering**:

- Producers MUST append `TraceEvent`s to `Trace.events` in the order they occur.
- Consumers MUST interpret `Trace.events` as an ordered sequence.

**Time fields**:

- `Trace.timestamp` and per-event `timestamp` fields are plain `u64` values with no unit or epoch defined by current code.
- **GAP**: the runtime does not currently define whether these are wall-clock time, monotonic time, or a logical clock, nor does it populate `Trace.timestamp` with a real value.

#### 2.2 TraceEvent

`TraceEvent` is a tagged enum (`#[serde(tag = "type")]`) with variants:

- `TileStart { tile_id: TileId, timestamp: u64, depth: u32 }`
- `TileEnd { tile_id: TileId, timestamp: u64, duration_ns: u64, cycles: Option<u64> }`
- `SequenceStart { name: String, timestamp: u64 }`
- `SequenceEnd { name: String, timestamp: u64, duration_ns: u64 }`

**Tile identifiers**:

- `tile_id` is a `TileId` newtype wrapper around a string; serialization treats it as the underlying string.

**Structural invariants (recommended; not enforced)**:

- A `TileEnd` event SHOULD correspond to a prior `TileStart` with the same `tile_id` at the same `depth`.
- A `SequenceEnd` event SHOULD correspond to a prior `SequenceStart` with the same `name`.
- **GAP**: current code does not enforce pairing, nesting, or timestamp monotonicity.

---

### 3. Commitment and fingerprint outputs (not implemented)

#### 3.1 Definitions

- A **trace commitment** is a fixed-length cryptographic digest that binds to the full trace contents (and, when applicable, the commitment scheme version and parameters).
- A **trace fingerprint** is a shorter identifier derived from a trace commitment, intended for indexing and human-facing references.

#### 3.2 Requirements on commitments and fingerprints (design targets)

When Raster introduces commitments and fingerprints, implementations MUST satisfy:

- **Domain separation**: each commitment MUST include an explicit domain separation tag that uniquely identifies the object type and commitment scheme version.
- **Canonical encoding**: each commitment MUST be computed over a canonical byte encoding of the committed data.
- **Binding target**: fingerprints MUST provide a 128-bit binding target (see §6).

**GAP (not implemented)**: Raster does not currently define a commitment scheme version, a canonical trace encoding for hashing, or any hash function choice for commitments.

---

### 4. Trace commitment scheme (proposed; GAP / not implemented)

This section specifies a concrete commitment scheme to unblock interoperable implementations. Raster does not yet implement this scheme.

#### 4.1 Commitment algorithm

Let:

- `DST` be the UTF-8 bytes of the domain separation string:
  - `raster.trace.commitment.v1`
- `ENC(trace)` be the canonical byte encoding of `trace` (see §4.2)
- `H` be a collision-resistant hash function with 32-byte output (e.g., SHA-256).

Then the trace commitment is:

\[
\mathrm{commitment} = H(\mathrm{DST} \parallel 0x00 \parallel \mathrm{ENC}(\mathrm{trace}))
\]

**Output format**:

- The commitment MUST be represented as 32 raw bytes.
- When rendered as text (e.g., JSON, logs), it MUST be lowercase hex with no `0x` prefix.

**GAP (code)**:

- Raster does not currently compute any such digest, and does not currently include a cryptographic hash implementation in its dependency set.

#### 4.2 Canonical encoding for commitment input

To make commitments stable across implementations, `ENC(trace)` MUST be deterministic.

Proposed rule (v1):

- `ENC(trace)` MUST be `postcard` encoding of a dedicated struct:
  - `TraceCommitmentInputV1 { trace: Trace }`

Rationale:

- `postcard` is already a workspace dependency and is used as Raster’s canonical tile I/O encoding.

**GAP (code)**:

- Raster does not currently define `TraceCommitmentInputV1` or any “canonical trace encoding” API surface.
- The `Trace` module is `std`-gated and currently uses `serde` derives only; no commitment encoder exists.

---

### 5. Fingerprint projection scheme (proposed; GAP / not implemented)

#### 5.1 Projection rule

Given a 32-byte commitment digest `C`, the 128-bit fingerprint `F` is:

- `F = C[0..16]` (the first 16 bytes, in byte order as produced by `H`)

**Text rendering**:

- The fingerprint MUST be rendered as 32 lowercase hex characters (16 bytes).

#### 5.2 Collision and ambiguity handling

- If a system uses fingerprints as lookup keys, it MUST treat a fingerprint match as a *candidate* match and SHOULD confirm by comparing the full commitment (or the full trace) when available.

**GAP (code)**:

- Raster does not currently compute commitments or fingerprints, so there is no implemented lookup mechanism and no collision-handling code.

---

### 6. Security rationale (binding target: 128 bits)

This section explains the 128-bit target for fingerprints.

- A 128-bit fingerprint provides approximately \(2^{128}\) second-preimage work for an attacker trying to find an alternate trace with the same fingerprint, assuming the underlying commitment digest is computed using a collision-resistant hash function and the projection is a simple truncation.
- For accidental collisions across many traces, the birthday bound applies: roughly \(2^{64}\) traces are needed before collisions become likely for uniformly random 128-bit values.

This is intended to make fingerprints safe for:

- user-facing identifiers
- database keys with low collision risk
- “window selection” indices used in replay protocols (where the full commitment can still be used for confirmation)

---

### 7. Windowing and `window_size` parameter usage (GAP / not implemented)

Raster’s broader execution/verify specs reference “window replay”. In support of that, implementations typically introduce a `window_size` parameter that determines how a trace is partitioned into contiguous windows and how window commitments/fingerprints are computed.

**Current status**:

- There is no `window_size` parameter in Raster CLI/runtime code today.
- There is no implemented algorithm for partitioning a trace into windows or computing per-window commitments.

**Proposed semantics (for future implementation)**:

- A “step” MUST be defined as a single `TraceEvent` in `Trace.events`.
- A window MUST be a contiguous slice of the event stream.
- `window_size` MUST be a positive integer specifying the maximum number of events per window.
- Window `i` MUST cover events in index range:
  - `[i * window_size, min((i + 1) * window_size, len(events)))`
- A window commitment SHOULD bind to:
  - the parent trace commitment (or trace identity)
  - the window index `i`
  - the canonical encoding of the window’s events

**GAP (spec integration)**:

- Other specs under `specs/Core/3. Execute/` that would define “window replay execution” and “trace generation” are currently empty in this repository snapshot, so there is no end-to-end, repo-consistent definition of window replay inputs/outputs yet.

---

### 8. Examples

#### 8.1 Example trace (illustrative JSON rendering)

If a trace is serialized as JSON via `serde_json` (not currently implemented by the tracer), it would look like:

```json
{
  "run_id": "run-123",
  "timestamp": 0,
  "events": [
    { "type": "SequenceStart", "name": "main", "timestamp": 100 },
    { "type": "TileStart", "tile_id": "double", "timestamp": 110, "depth": 0 },
    { "type": "TileEnd", "tile_id": "double", "timestamp": 120, "duration_ns": 1000, "cycles": 4242 },
    { "type": "SequenceEnd", "name": "main", "timestamp": 130, "duration_ns": 2000 }
  ]
}
```

#### 8.2 Example fingerprint rendering (format)

Given a (hypothetical) 32-byte commitment:

- `C = 32 bytes`

the fingerprint is:

- `F = first 16 bytes of C`
- rendered as 32 hex characters, e.g.:

```text
9f2a0c1e6b5d4c3a1122334455667788
```

**Note**: the numeric value above is format-only; Raster does not yet implement commitment computation.

