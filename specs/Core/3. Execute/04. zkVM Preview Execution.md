## zkVM Preview Execution (RISC0 backend)

This document specifies how Raster executes tiles in a zkVM-backed “preview” environment as implemented today, using the RISC0 zkVM backend. It covers:

- What is executed (guest wrapper program per tile)
- How inputs/outputs are encoded and passed
- What receipts/proofs are generated (when enabled)
- What public inputs/outputs are bound by verification
- How tile artifact identities are (and are not yet) enforced

### Scope

- **In scope**: executing a single tile in the RISC0 zkVM backend, and the CLI “preview sequence” behavior that runs multiple tiles in estimate mode.
- **Out of scope**: end-to-end program proving across multi-tile sequences, trace commitments, fraud proofs, and on-chain verification (those are specified elsewhere).

---

## Code audit tasks (exact places to inspect)

Use these locations to confirm behavior, error surfaces, and IO formats:

- **zkVM integration entrypoints**
  - `crates/raster-backend-risc0/src/risc0.rs`
    - `impl Backend for Risc0Backend`
      - `compile_tile` (ELF compilation and method/image ID computation)
      - `execute_tile` (estimate vs prove, input env format, receipt generation)
      - `verify_receipt` (receipt deserialization + verification)
    - `is_gpu_available`, `is_metal_available`, `is_cuda_available` (GPU feature gating)
  - `crates/raster-backend/src/backend.rs`
    - `ExecutionMode` (Estimate vs Prove { verify })
    - `CompilationOutput` (ELF + method_id carrier)
    - `TileExecution` (output/cycles/proof_cycles/receipt/verified)
    - `calculate_proof_cycles` (proof-cycle padding rule)

- **Guest wrapper program generation (mapping tiles → ELFs)**
  - `crates/raster-backend-risc0/src/guest_builder.rs`
    - `GuestBuilder::generate_guest_main` (guest `main`, env reads/writes, journal commit)
    - `GuestBuilder::generate_guest_cargo_toml` (no_std, risc0 target, dependencies)
    - `GuestBuilder::build_guest` (toolchain discovery and `cargo build --target riscv32im-risc0-zkvm-elf`)
    - `GuestBuilder::write_artifacts` (writes `guest.elf`, `method_id`, `manifest.json`)

- **Tile ABI wrapper (what input/output bytes mean)**
  - `crates/raster-macros/src/lib.rs`
    - `#[tile]` macro-generated wrapper `pub fn __raster_tile_entry_<tile>(input: &[u8]) -> Result<Vec<u8>>`
    - Input deserialization and output serialization (`raster::core::postcard`)

- **CLI wiring / execution modes**
  - `crates/raster-cli/src/commands.rs`
    - `run` (tile execution in estimate/prove/verify modes, loads artifacts)
    - `preview` (sequence execution in estimate mode only, pipelined output→input)

- **Tile artifact directory layout and caching**
  - `crates/raster-compiler/src/builder.rs`
    - `Builder::write_tile_artifacts` (writes canonical artifact files including `manifest.json`)
    - `Builder::needs_compilation`, `load_cached_compilation` (cache and manifest usage)

---

## Execution model

### Unit of execution: “guest program per tile”

For RISC0 execution, each tile is executed as a distinct RISC0 guest program:

- The guest program is generated on demand and compiled into a RISC0-target ELF.
- The guest `main` reads an input byte string from the zkVM environment.
- The guest calls the tile’s macro-generated ABI wrapper function.
- The guest commits the resulting output bytes to the RISC0 journal.

As implemented, the guest program is auto-generated by `GuestBuilder::generate_guest_main` and imports a symbol named:

- `__raster_tile_entry_<tile_id_with_hyphens_replaced_by_underscores>`

### Tile ABI bytes (postcard)

The tile ABI wrapper generated by `#[tile]` defines the meaning of the input/output bytes:

- The input bytes **MUST** be a `postcard` encoding of:
  - the single argument type (if the tile takes one argument), or
  - a tuple of argument types (if the tile takes multiple arguments), or
  - unit `()` (if the tile takes zero arguments).
- The output bytes **MUST** be a `postcard` encoding of:
  - the function’s return value, or
  - the `Ok(T)` value if the tile returns a `Result<T, _>`.

If deserialization fails, the wrapper returns an error. If serialization fails, the wrapper returns an error.

**Implementation note:** the generated RISC0 guest currently calls the wrapper and `expect`s success; failure becomes a guest panic (see “Errors and gaps”).

---

## Inputs/outputs and public claims

### Private input (zkVM environment)

For each tile execution, the host provides the tile input bytes to the zkVM via the RISC0 `ExecutorEnv` as:

1. A 32-bit little-endian length prefix (`u32`)
2. Exactly that many raw bytes

The guest reads the same format:

1. `let input_len: u32 = env::read();`
2. `env::read_slice(&mut input);`

The input bytes are **private** to the prover/executor by default (they are not committed to the journal by Raster’s generated guest).

### Public output (journal)

The guest commits exactly one byte string to the RISC0 journal:

- `commit_slice(&output)`

The journal bytes are treated as the tile execution output:

- In estimate mode, the host returns `session.journal.bytes` as output.
- In prove mode, the host returns `receipt.journal.bytes` as output.

Therefore, the journal bytes are the public output of the zkVM execution.

### Proven statement (what verification binds)

When a receipt is verified against an image ID, verification establishes (at minimum) that:

- The committed journal bytes were produced by executing the specified RISC0 guest image (identified by its image ID / method ID) on some private input stream.

Raster currently commits only the output bytes, so verification does **not** bind:

- the original input bytes as public data, or
- any additional public metadata (tile ID, version, backend, etc.).

---

## Artifacts and identity

### Artifact directory layout (RISC0)

For a tile with ID `<tile_id>`, the RISC0 backend artifacts are written under:

- `target/raster/tiles/<tile_id>/risc0/`

The following files are produced/expected:

- `guest.elf`
  - The compiled RISC0 guest ELF bytes.
- `method_id`
  - Hex encoding of the method/image ID bytes as computed from `guest.elf`.
- `manifest.json`
  - JSON metadata written by the compiler `Builder`.

The compiler `Builder` writes `manifest.json` with these fields:

- `tile_id` (string)
- `backend` (string, `"risc0"`)
- `method_id` (string, hex)
- `elf_size` (number)
- `source_hash` (string or null/absent; used for cache invalidation)

### Method/image ID computation

The RISC0 backend computes the method/image ID as:

- `method_id = risc0_zkvm::compute_image_id(elf)`

The method ID bytes **MUST** be treated as the identity of the guest image for verification purposes.

### Identity enforcement during verification (current behavior)

When verifying a receipt, Raster currently:

- recomputes `image_id = compute_image_id(compilation.elf)`, and
- checks `receipt.verify(image_id)`.

This enforces that the receipt corresponds to the provided ELF’s image ID.

**Gap (artifact binding):** Raster currently does **not** check that `compilation.method_id` (or the on-disk `method_id` file) equals `compute_image_id(compilation.elf)`. Tooling that loads artifacts from disk can therefore accidentally pair a mismatched `guest.elf` and `method_id` without an immediate error, and verification will ignore the loaded `method_id` value.

**Expected invariant (not enforced yet):**

- When both are available, the loaded/stored `method_id` value **SHOULD** equal `compute_image_id(guest.elf)`, and execution/verification **SHOULD** fail if they differ.

---

## Execution modes

### Estimate mode (preview)

In `ExecutionMode::Estimate`:

- The host executes the guest ELF without proving.
- The host returns:
  - `output = session.journal.bytes`
  - `cycles = session.cycles()`
  - `proof_cycles = calculate_proof_cycles(cycles)`
  - no receipt bytes
  - no verification result

`calculate_proof_cycles` pads “compute cycles” to a proving-cost estimate as:

- If `cycles <= 65536`, then `proof_cycles = 65536`
- Else `proof_cycles = next_power_of_two(cycles)`

### Prove mode (receipt generation)

In `ExecutionMode::Prove { verify: false }`:

- The host proves execution of the guest ELF and obtains a RISC0 receipt.
- The host returns:
  - `output = receipt.journal.bytes`
  - `cycles = prove_info.stats.total_cycles`
  - `proof_cycles = calculate_proof_cycles(cycles)`
  - `receipt = bincode(Receipt)` (see below)
  - `verified = false`

**Gap (verified semantics):** `verified = false` currently means either “verification was not requested” or “verification failed”; callers cannot distinguish these cases from the return value alone.

### Prove+verify mode (receipt generation + verification)

In `ExecutionMode::Prove { verify: true }`:

- The host proves execution to obtain a receipt.
- The host computes `image_id = compute_image_id(elf)`.
- The host attempts `receipt.verify(image_id)`.
- The host returns:
  - `receipt = bincode(Receipt)`
  - `verified = true` iff `verify` succeeded, else `false`.

**Gap (diagnostics):** verification failures are currently converted to `false` without returning the underlying verification error.

### GPU acceleration selection

If GPU acceleration is enabled on the backend (`with_gpu(true)`) and a GPU feature is available (`metal` on macOS or `cuda`), proving uses:

- `prove_with_opts(env, elf, ProverOpts::default())`

Otherwise proving uses:

- `prove(env, elf)`

The resulting receipt semantics are the same.

---

## Receipt format and verification

### Receipt bytes (current behavior)

When a receipt is produced, Raster serializes the RISC0 `Receipt` object using `bincode`:

- `receipt_bytes = bincode::serialize(&receipt)`

When verifying a receipt, Raster deserializes it using `bincode`:

- `receipt = bincode::deserialize::<risc0_zkvm::Receipt>(receipt_bytes)`

**Gap (stability):** no stable, versioned receipt encoding is specified yet. `bincode` serialization depends on Rust type definitions and crate versions; receipt bytes should be treated as an implementation detail and are not guaranteed to be portable across Raster/RISC0 versions.

### Verification inputs and outputs

Verification takes:

- `compilation.elf` (to recompute the image ID), and
- `receipt_bytes` (bincode-serialized receipt)

Verification returns:

- `true` if `receipt.verify(image_id)` succeeds, otherwise `false` (or an error if deserialization/image_id computation fails).

---

## Sequence preview behavior (CLI)

The CLI “preview sequence” command executes a discovered sequence by:

- Compiling each tile as needed (using the compiler `Builder` cache).
- Executing each tile in `ExecutionMode::Estimate`.
- Feeding each tile’s output bytes as the next tile’s input bytes.
- Reporting per-tile `cycles` and `proof_cycles` and totals.

Sequence preview currently does **not**:

- generate receipts, or
- verify receipts, or
- bind a sequence-wide identity/commitment.

---

## Errors and gaps (as implemented)

### Guest/toolchain build failures

Guest build can fail due to:

- Missing RISC0 toolchain (`rzup install` not run) or missing `cargo` under the expected toolchain path.
- RISC0 guest compilation errors (Rust compile errors or missing dependencies).
- Missing output ELF at the expected location.

These failures surface as backend errors.

### Tile execution failures inside the guest

The generated guest currently calls:

- `__raster_tile_entry_<tile>(input).expect("Tile execution failed")`

Therefore:

- If the wrapper returns an error (e.g., postcard decode/encode failure), the guest panics.
- A guest panic results in a host-side execution/proving error.

**Gap (error propagation):** there is currently no structured error channel from guest to host for tile failures; failures do not produce a typed Raster error or a structured journal entry.

### Input encoding mismatch hazards

The tile wrapper uses `postcard` for decoding/encoding tile arguments and return values, so:

- Inputs passed to zkVM execution **MUST** be postcard-encoded according to the tile’s signature.

Supplying non-postcard bytes will cause wrapper error → guest panic → execution failure.

---

## Examples

### Example: computing tile input/output bytes (host-side)

For a tile `double(x: u64) -> u64`, the host input bytes are:

- `postcard::to_allocvec(&42u64)`

The host output bytes can be decoded as:

- `postcard::from_bytes::<u64>(&output_bytes)`

### Example: zkVM environment input format

Given `input_bytes` (postcard-encoded), the host provides to the RISC0 executor:

- `u32(len(input_bytes))` followed by `input_bytes`

The guest reads that and passes `input_bytes` to `__raster_tile_entry_double`.

### Example: artifact directory (RISC0)

After building tile `double` with the RISC0 backend, the artifact directory is:

- `target/raster/tiles/double/risc0/`

and it contains:

- `guest.elf`
- `method_id` (hex string)
- `manifest.json` (includes `backend: "risc0"`, `method_id`, `elf_size`, and optional `source_hash`)

